\chapter{Templates}

\section{Template C++}

\begin{lstlisting}[language=C++]
#include <bits/stdc++.h>
#define endl '\n'
using namespace std;
using ll = long long;

void solve() {

}

signed main() {
    cin.tie(0)->sync_with_stdio(0);
    solve();
}
\end{lstlisting}

\section{Template Debug}

Template para debugar variáveis em C++. As primeiras linhas são opcionais, é pra permitir que seja possível debugar pair e vector.
Para usar, basta compilar com a flag \texttt{-DBRUTE} (o \texttt{run} já tem essa flag). E no código usar \texttt{debug(x, y, z)}.

\begin{lstlisting}[language=C++]

template<typename T, typename U> 
ostream& operator<<(ostream& os, const pair<T, U>& p) { // opcional
    os << "(" << p.first << ", " << p.second << ")";
    return os;
}
template<typename T> 
ostream& operator<<(ostream& os, const vector<T>& v) { // opcional
    os << "{";
    int n = (int)v.size();
    for (int i = 0; i < n; i++) {
        os << v[i];
        if (i < n - 1) os << ", ";
    }
    os << "}";
    return os;
}

void _print() {}
template <typename T, typename... U> void _print(T a, U... b) {
    if (sizeof...(b)) {
        cerr << a << ", ";
        _print(b...);
    } else cerr << a;
}
#ifdef BRUTE
#define debug(x...) cerr << "[" << #x << "] = [", _print(x), cerr << "]" << endl
#else
#define debug(...)
#endif
\end{lstlisting}

\section{Vimrc}

Template de arquivo \texttt{\$HOME/.vimrc} para o vim.

Recomendado copiar o arquivo \texttt{/etc/vim/vimrc}, e adicionar as linhas abaixo no final.

\begin{lstlisting}
set nu ai si cindent et ts=4 sw=4 so=10 nosm nohls
inoremap {} {}<left><return><up><end><return>
\end{lstlisting}

\section{Run}

Arquivo útil para compilar e rodar um programa em C++ com flags que ajudam a debugar.
Basta criar um arquivo chamado \texttt{run}, adicionar o código abaixo e dar permissão de execução com \texttt{chmod +x run}.
Para executar um arquivo \texttt{a.cpp}, basta rodar \texttt{./run a.cpp}.

\begin{lstlisting}
#!/bin/bash
g++ -std=c++20 -DBRUTE -O2 -Wall -Wextra -Wconversion -Wfatal-errors -fsanitize=address,undefined $1 && ./a.out
\end{lstlisting}

\section{Stress Test}

Script muito útil para achar casos em que sua solução gera uma resposta incorreta.
Deve-se criar uma solução bruteforce (que garantidamente está correta, ainda que seja lenta) e um gerador de casos aleatórios para seu problema.

\begin{lstlisting}[language=Bash]

#!/bin/bash
set -e

g++ -O2 gen.cpp -o gen # pode fazer o gerador em python se preferir
g++ -O2 brute.cpp -o brute
g++ -O2 code.cpp -o code

for((i = 1; ; ++i)); do
    ./gen $i > in
    ./code < in > out
    ./brute < in > ok
    diff -w out ok || break
    echo "Passed test: " $i
done

echo "WA on the following test:"
cat in
echo "Your answer is:"
cat out
echo "Correct answer is:"
cat ok

\end{lstlisting}

\section{Números aleatórios em C++}

É possível usar a função \texttt{rand()} para gerar números aleatórios em C++.
Útil para gerar casos aleatórios em stress test.

\begin{lstlisting}[language=C++]
#include <bits/stdc++.h>
using namespace std;

int main() {
    srand(time(0));
    for (int i = 0; i < 10; i++) {
        cout << rand() << endl;
    }
}

\end{lstlisting}

Para usar números aleatórios em soluções, recomenda-se o uso do \texttt{mt19937}.

\begin{lstlisting}[language=C++]
#include <bits/stdc++.h>
using namespace std;

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

int main() {
    for (int i = 0; i < 10; i++) {
        cout << rng() << endl;
    }
}

\end{lstlisting}

\section{Custom Hash}

As funções de hash padrão do \texttt{unordered\_map} e \texttt{unordered\_set} são muito propícias a colisões (principalmente se o setter da questão criar casos de teste pensando nisso).
Para evitar isso, é possível criar uma função de hash customizada.

\begin{lstlisting}[language=C++]
#include <bits/stdc++.h>
using namespace std;

struct custom_hash {
    static uint64_t splitmix64(uint64_t x) {
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};

int main() {
    unordered_map<long long, int, custom_hash> mp;
    mp[1] = 1;
    cout << mp[1] << endl;
}
\end{lstlisting}

Entretanto, é bem raro ser necessário usar isso. Geralmente o fator $\mathcal{O}(\log n)$ de um \texttt{map} é suficiente.