# [Merge Sort Tree](mergesort_tree.cpp)

Árvore muito semelhante a uma Segment Tree, mas ao invés de armazenar um valor em cada nodo, armazena um vetor ordenado. Permite realizar consultas do tipo: `count(L, R, A, B)` que retorna quantos elementos no intervalo $[L, R]$ estão no intervalo $[A, B]$ em $\mathcal{O}(\log^2 N)$. Em outras palavras, count(L, R, A, B) retorna quantos elementos $X$ existem no intervalo $[L, R]$ tal que $A \leq X \leq B$.

**Obs**: o método `kth` presente nessa implementação encontra o k-ésimo elemento no intervalo $[L, R]$ em $\mathcal{O}(\log^3 N)$. É possível otimizar esse método para $\mathcal{O}(\log^2 N)$, basta se criar um vetor que possui pares da forma `[A[i], i]` e ordená-lo de acordo com o valor de `A[i]`, agora, construa a Merge Sort Tree com esse vetor e no merge faça a união mantendo os valores de `i` ordenados. Dessa forma, sua Merge Sort Tree guardará em um nodo que representa o intervalo $[L, R]$ os índices ordenados de todos os elementos que estão entre o $(L + 1)$-ésimo e o $(R + 1)$-ésimo menor elemento do vetor original. Assim, para encontrar o k-ésimo elemento no intervalo $[L, R]$ basta fazer uma busca binária semelhante a busca binária de encontrar $k$-ésimo menor elemento em uma Segment Tree.