\documentclass[10pt, a4paper, oneside]{book}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amssymb,amsmath}
\usepackage[brazil]{babel}
\usepackage[landscape, a4paper, total={6in, 8in}]{geometry}
\usepackage{comment}
\usepackage{datetime}
\usepackage[pdfusetitle]{hyperref}
\usepackage[all]{xy}
\usepackage{graphicx}
\addtolength{\parskip}{.5\baselineskip}
\setlength{\parindent}{0pt}

\usepackage{fancyhdr}

\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{colortbl}
\usepackage{xcolor}
\definecolor{commentgreen}{RGB}{2,112,10}
\definecolor{eminence}{RGB}{210,31,60}
\usepackage{listings} %biblioteca pro codigo

\usepackage{multicol} %biblioteca pra duas colunas
\setlength{\columnseprule}{0.5pt}
\setlength{\columnsep}{25pt} %distancia do texto ate a barra
\def\columnseprulecolor{\color{black}}

% \usepackage{color}    %deixa o codigo colorido bonitinho
\geometry{
	a4paper,
	left=10mm,
	right=10mm,
	top=1in,
	bottom=1in,
}

\definecolor{gray}{rgb}{0.2, 0.2, 0.2} %cor pros comentarios
% \renewcommand{\footnotesize}{\small} %isso eh pra mudar o tamanho da fonte do codigo

\lstset{
	language=C++,
	breaklines=true,
	numbers=left,
	breakatwhitespace=true,
	numbersep=5pt,
	rulecolor=\color{black},
	%   xleftmargin=\parindent,
	% frame=single,
	xleftmargin=0.4cm,
	commentstyle=\color{commentgreen},
	keywordstyle=\color{blue},
 	basicstyle=\ttfamily\footnotesize,
	showspaces=false,
	showstringspaces=false,
	columns=fullflexible,
	escapeinside={<@}{@>},
	tabsize=4,
	captionpos=b,                    
	extendedchars=true,              
	numberstyle=\tiny\color{blue}, 
	stringstyle=\color{purple},
}
% \lstset{ %opcoes pro codigo
% 	language=C++,
% 	breaklines=true,
% 	keywordstyle=\color{blue}\bfseries,
% 	commentstyle=\color{darkgray},
% 	breakatwhitespace=true,
% 	% frame=single,
% 	% numbers=left,
% 	% xleftmargin=0.50cm,
% 	rulecolor=\color{black},
% 	showstringspaces=false
% 	stringstyle=\color{purple},
% 	tabsize=2,
% 	basicstyle=\footnotesize,
% 	basicstyle=\ttfamily\footnotesize, % fonte pro codigo, nao sei qual dos dois eu prefiro
% }
\lstset{literate=
	{á}{{\'a\lst@whitespacefalse}}1 {é}{{\'e\lst@whitespacefalse}}1
	{í}{{\'i\lst@whitespacefalse}}1 {ó}{{\'o\lst@whitespacefalse}}1
	{ú}{{\'u\lst@whitespacefalse}}1
	{Á}{{\'A\lst@whitespacefalse}}1 {É}{{\'E\lst@whitespacefalse}}1
	{Í}{{\'I\lst@whitespacefalse}}1 {Ó}{{\'O\lst@whitespacefalse}}1
	{Ú}{{\'U\lst@whitespacefalse}}1
	{à}{{\`a\lst@whitespacefalse}}1 {è}{{\`e\lst@whitespacefalse}}1
	{ì}{{\`i\lst@whitespacefalse}}1 {ò}{{\`o\lst@whitespacefalse}}1
	{ù}{{\`u\lst@whitespacefalse}}1
	{À}{{\`A\lst@whitespacefalse}}1
	{È}{{\'E\lst@whitespacefalse}}1 {Ì}{{\`I\lst@whitespacefalse}}1
	{Ò}{{\`O\lst@whitespacefalse}}1 {Ù}{{\`U\lst@whitespacefalse}}1
	{ä}{{\"a\lst@whitespacefalse}}1 {ë}{{\"e\lst@whitespacefalse}}1
	{ï}{{\"i\lst@whitespacefalse}}1 {ö}{{\"o\lst@whitespacefalse}}1
	{ü}{{\"u\lst@whitespacefalse}}1
	{Ä}{{\"A\lst@whitespacefalse}}1 {Ë}{{\"E\lst@whitespacefalse}}1
	{Ï}{{\"I\lst@whitespacefalse}}1 {Ö}{{\"O\lst@whitespacefalse}}1
	{Ü}{{\"U\lst@whitespacefalse}}1
	{â}{{\^a\lst@whitespacefalse}}1 {ê}{{\^e\lst@whitespacefalse}}1
	{î}{{\^i\lst@whitespacefalse}}1 {ô}{{\^o\lst@whitespacefalse}}1
	{û}{{\^u\lst@whitespacefalse}}1
	{Â}{{\^A\lst@whitespacefalse}}1 {Ê}{{\^E\lst@whitespacefalse}}1
	{Î}{{\^I\lst@whitespacefalse}}1 {Ô}{{\^O\lst@whitespacefalse}}1
	{Û}{{\^U\lst@whitespacefalse}}1
	{Ã}{{\~A\lst@whitespacefalse}}1 {ã}{{\~a\lst@whitespacefalse}}1
	{Õ}{{\~O\lst@whitespacefalse}}1 {õ}{{\~o\lst@whitespacefalse}}1
	{œ}{{\oe\lst@whitespacefalse}}1 {Œ}{{\OE\lst@whitespacefalse}}1
	{æ}{{\ae\lst@whitespacefalse}}1 {Æ}{{\AE\lst@whitespacefalse}}1
	{ß}{{\ss\lst@whitespacefalse}}1
	{ű}{{\H{u}\lst@whitespacefalse}}1 {Ű}{{\H{U}\lst@whitespacefalse}}1
	{ő}{{\H{o}\lst@whitespacefalse}}1 {Ő}{{\H{O}\lst@whitespacefalse}}1
	{ç}{{\c c\lst@whitespacefalse}}1 {Ç}{{\c C\lst@whitespacefalse}}1
	{ø}{{\o\lst@whitespacefalse}}1
	{å}{{\r a\lst@whitespacefalse}}1 {Å}{{\r A\lst@whitespacefalse}}1
	{€}{{\euro\lst@whitespacefalse}}1 {£}{{\pounds\lst@whitespacefalse}}1
	{«}{{\guillemotleft\lst@whitespacefalse}}1
	{»}{{\guillemotright\lst@whitespacefalse}}1
	{ñ}{{\~n\lst@whitespacefalse}}1 {Ñ}{{\~N\lst@whitespacefalse}}1
	{¿}{{?`\lst@whitespacefalse}}1
	{º}{{\textordmasculine\lst@whitespacefalse}}1
	%{~}{{\raisebox{0.5ex}{\texttildelow}\lst@whitespacefalse}}1
	%{^}{{\raisebox{-0.75ex}{\^{}}\lst@whitespacefalse}}1
}

% \usepackage{fancyhdr}
% \fancypagestyle{plain}{
%   \fancyhf{}
%   \fancyfoot[C]{Os códigos foram testados em C++20, ao compilar, lembre-se de utilizar a flag \texttt{-std=c++20}.}
%   \renewcommand{\headrulewidth}{0pt}
%   \renewcommand{\footrulewidth}{0pt}
% }
% \pagestyle{plain}

\title{Almanaque de Códigos pra\\Maratona de Programação}
\author{BRUTE UDESC}

\begin{document}

\twocolumn
\date{\today}
\maketitle

\renewcommand{\contentsname}{Índice} %troca o nome do indice para indice

\tableofcontents\chapter{C++}

\section{Compilador}

Para compilar um arquivo \texttt{.cpp} com o compilador \texttt{g++}, usar o comando:

\begin{lstlisting}[language=bash]
    g++ -std=c++20 -O2 arquivo.cpp
\end{lstlisting}

\textbf{Obs:} a flag \texttt{-std=c++20} é para usar a versão 20 do C++, os códigos desse Almanaque são testados com essa versão.

Algumas flags úteis para o \texttt{g++} são:

\begin{itemize}
    \item \texttt{-O2}: Otimizações de compilação
    \item \texttt{-Wall}: Mostra todos os warnings
    \item \texttt{-Wextra}: Mostra mais warnings
    \item \texttt{-Wconversion}: Mostra warnings para conversões implícitas
    \item \texttt{-fsanitize=address}: Habilita o AddressSanitizer
    \item \texttt{-fsanitize=undefined}: Habilita o UndefinedBehaviorSanitizer
\end{itemize}

Todas essas flags já estão presente no script `run` da seção Extra.

\section{STL (Standard Template Library)}

Os templates da STL são estruturas de dados e algoritmos já implementadas em \texttt{C++} que facilitam as implementações, além de serem muito eficients.
Em geral, todas estão incluídas no cabeçalho \texttt{<bits/stdc++.h>}. As estruturas são templates genéricos, podem ser usadas com qualquer tipo, todos os exemplos a seguir são com \texttt{int} apenas por motivos de simplicidade.

\subsection{Vector}

Um vetor dinâmico (que pode crescer e diminuir de tamanho).

\begin{itemize}
    \item \texttt{vector<int> v(n, x)}: Cria um vetor de inteiros com \texttt{n} elementos, todos inicializados com x - $\mathcal{O}(n)$
    \item \texttt{v.push\_back(x)}: Adiciona o elemento \texttt{x} no final do vetor - $\mathcal{O}(1)$
    \item \texttt{v.pop\_back()}: Remove o último elemento do vetor - $\mathcal{O}(1)$
    \item \texttt{v.size()}: Retorna o tamanho do vetor - $\mathcal{O}(1)$
    \item \texttt{v.empty()}: Retorna \texttt{true} se o vetor estiver vazio - $\mathcal{O}(1)$
    \item \texttt{v.clear()}: Remove todos os elementos do vetor - $\mathcal{O}(n)$
    \item \texttt{v.front()}: Retorna o primeiro elemento do vetor - $\mathcal{O}(1)$
    \item \texttt{v.back()}: Retorna o último elemento do vetor - $\mathcal{O}(1)$
    \item \texttt{v.begin()}: Retorna um iterador para o primeiro elemento do vetor - $\mathcal{O}(1)$
    \item \texttt{v.end()}: Retorna um iterador para o elemento seguinte ao último do vetor - $\mathcal{O}(1)$
    \item \texttt{v.insert(it, x)}: Insere o elemento \texttt{x} na posição apontada pelo iterador \texttt{it} - $\mathcal{O}(n)$
    \item \texttt{v.erase(it)}: Remove o elemento apontado pelo iterador \texttt{it} - $\mathcal{O}(n)$
    \item \texttt{v.erase(it1, it2)}: Remove os elementos no intervalo \texttt{[it1, it2)} - $\mathcal{O}(n)$
    \item \texttt{v.resize(n)}: Redimensiona o vetor para \texttt{n} elementos - $\mathcal{O}(n)$
    \item \texttt{v.resize(n, x)}: Redimensiona o vetor para \texttt{n} elementos, todos inicializados com \texttt{x} - $\mathcal{O}(n)$
\end{itemize}

\subsection{Pair}

Um par de elementos (de tipos possivelmente diferentes).

\begin{itemize}
    \item \texttt{pair<int, int> p}: Cria um par de inteiros - $\mathcal{O}(1)$
    \item \texttt{p.first}: Retorna o primeiro elemento do par - $\mathcal{O}(1)$
    \item \texttt{p.second}: Retorna o segundo elemento do par - $\mathcal{O}(1)$
\end{itemize}

\subsection{Set}

Um conjunto de elementos únicos. Por baixo, é uma árvore de busca binária balanceada.

\begin{itemize}
    \item \texttt{set<int> s}: Cria um conjunto de inteiros - $\mathcal{O}(1)$
    \item \texttt{s.insert(x)}: Insere o elemento \texttt{x} no conjunto - $\mathcal{O}(\log n)$
    \item \texttt{s.erase(x)}: Remove o elemento \texttt{x} do conjunto - $\mathcal{O}(\log n)$
    \item \texttt{s.find(x)}: Retorna um iterador para o elemento \texttt{x} no conjunto, ou \texttt{s.end()} se não existir - $\mathcal{O}(\log n)$
    \item \texttt{s.size()}: Retorna o tamanho do conjunto - $\mathcal{O}(1)$
    \item \texttt{s.empty()}: Retorna \texttt{true} se o conjunto estiver vazio - $\mathcal{O}(1)$
    \item \texttt{s.clear()}: Remove todos os elementos do conjunto - $\mathcal{O}(n)$
    \item \texttt{s.begin()}: Retorna um iterador para o primeiro elemento do conjunto - $\mathcal{O}(1)$
    \item \texttt{s.end()}: Retorna um iterador para o elemento seguinte ao último do conjunto - $\mathcal{O}(1)$
\end{itemize}

\subsection{Multiset}

Basicamente um \texttt{set}, mas permite elementos repetidos. Possui todos os métodos de um \texttt{set}.

Declaração: \texttt{multiset<int> ms}.

Um detalhe é que, ao usar o método \texttt{erase}, ele remove todas as ocorrências do elemento. Para remover apenas uma ocorrência, usar \texttt{ms.erase(ms.find(x))}.

\subsection{Map}

Um conjunto de pares chave-valor, onde as chaves são únicas. Por baixo, é uma árvore de busca binária balanceada.

\begin{itemize}
    \item \texttt{map<int, int> m}: Cria um mapa de inteiros para inteiros - $\mathcal{O}(1)$
    \item \texttt{m[key]}: Retorna o valor associado à chave \texttt{key} - $\mathcal{O}(\log n)$
    \item \texttt{m[key] = value}: Associa o valor \texttt{value} à chave \texttt{key} - $\mathcal{O}(\log n)$
    \item \texttt{m.erase(key)}: Remove a chave \texttt{key} do mapa - $\mathcal{O}(\log n)$
    \item \texttt{m.find(key)}: Retorna um iterador para o par chave-valor com chave \texttt{key}, ou \texttt{m.end()} se não existir - $\mathcal{O}(\log n)$
    \item \texttt{m.size()}: Retorna o tamanho do mapa - $\mathcal{O}(1)$
    \item \texttt{m.empty()}: Retorna \texttt{true} se o mapa estiver vazio - $\mathcal{O}(1)$
    \item \texttt{m.clear()}: Remove todos os pares chave-valor do mapa - $\mathcal{O}(n)$
    \item \texttt{m.begin()}: Retorna um iterador para o primeiro par chave-valor do mapa - $\mathcal{O}(1)$
    \item \texttt{m.end()}: Retorna um iterador para o par chave-valor seguinte ao último do mapa - $\mathcal{O}(1)$
\end{itemize}

\subsection{Queue}

Uma fila (primeiro a entrar, primeiro a sair).

\begin{itemize}
    \item \texttt{queue<int> q}: Cria uma fila de inteiros - $\mathcal{O}(1)$
    \item \texttt{q.push(x)}: Adiciona o elemento \texttt{x} no final da fila - $\mathcal{O}(1)$
    \item \texttt{q.pop()}: Remove o primeiro elemento da fila - $\mathcal{O}(1)$
    \item \texttt{q.front()}: Retorna o primeiro elemento da fila - $\mathcal{O}(1)$
    \item \texttt{q.size()}: Retorna o tamanho da fila - $\mathcal{O}(1)$
    \item \texttt{q.empty()}: Retorna \texttt{true} se a fila estiver vazia - $\mathcal{O}(1)$
\end{itemize}

\subsection{Priority Queue}

Uma fila de prioridade (o maior elemento é o primeiro a sair).

\begin{itemize}
    \item \texttt{priority\_queue<int> pq}: Cria uma fila de prioridade de inteiros - $\mathcal{O}(1)$
    \item \texttt{pq.push(x)}: Adiciona o elemento \texttt{x} na fila de prioridade - $\mathcal{O}(\log n)$
    \item \texttt{pq.pop()}: Remove o maior elemento da fila de prioridade - $\mathcal{O}(\log n)$
    \item \texttt{pq.top()}: Retorna o maior elemento da fila de prioridade - $\mathcal{O}(1)$
    \item \texttt{pq.size()}: Retorna o tamanho da fila de prioridade - $\mathcal{O}(1)$
    \item \texttt{pq.empty()}: Retorna \texttt{true} se a fila de prioridade estiver vazia - $\mathcal{O}(1)$
\end{itemize}

Para fazer uma fila de prioridade que o menor elemento é o primeiro a sair, usar \texttt{priority\_queue< int, vector<int>, greater<> > pq}.

\subsection{Stack}

Uma pilha (último a entrar, primeiro a sair).

\begin{itemize}
    \item \texttt{stack<int> s}: Cria uma pilha de inteiros - $\mathcal{O}(1)$
    \item \texttt{s.push(x)}: Adiciona o elemento \texttt{x} no topo da pilha - $\mathcal{O}(1)$
    \item \texttt{s.pop()}: Remove o elemento do topo da pilha - $\mathcal{O}(1)$
    \item \texttt{s.top()}: Retorna o elemento do topo da pilha - $\mathcal{O}(1)$
    \item \texttt{s.size()}: Retorna o tamanho da pilha - $\mathcal{O}(1)$
    \item \texttt{s.empty()}: Retorna \texttt{true} se a pilha estiver vazia - $\mathcal{O}(1)$
\end{itemize}

\subsection{Funções úteis}

\begin{itemize}
    \item \texttt{min(a, b)}: Retorna o menor entre \texttt{a} e \texttt{b} - $\mathcal{O}(1)$
    \item \texttt{max(a, b)}: Retorna o maior entre \texttt{a} e \texttt{b} - $\mathcal{O}(1)$
    \item \texttt{abs(a)}: Retorna o valor absoluto de \texttt{a} - $\mathcal{O}(1)$
    \item \texttt{swap(a, b)}: Troca os valores de \texttt{a} e \texttt{b} - $\mathcal{O}(1)$
    \item \texttt{sqrt(a)}: Retorna a raiz quadrada de \texttt{a} - $\mathcal{O}(\log a)$
    \item \texttt{ceil(a)}: Retorna o menor inteiro maior ou igual a \texttt{a} - $\mathcal{O}(1)$
    \item \texttt{floor(a)}: Retorna o maior inteiro menor ou igual a \texttt{a} - $\mathcal{O}(1)$
    \item \texttt{round(a)}: Retorna o inteiro mais próximo de \texttt{a} - $\mathcal{O}(1)$
\end{itemize}

\subsection{Funções úteis para vetores}

Para usar em \texttt{std::vector}, sempre passar \texttt{v.begin()} e \texttt{v.end()} como argumentos pra essas funções.

Se for um vetor estilo \texttt{C}, usar \texttt{v} e \texttt{v + n}. 
Exemplo:
\begin{lstlisting}[language=C++]
    int v[10];
    sort(v, v + 10);
\end{lstlisting}

\textbf{Lembrete:} \texttt{v.end()} é um iterador para o elemento seguinte ao último do vetor, então não é um iterador válido.

As funções de vetor em geral são da forma \texttt{[L, R)}, ou seja, \texttt{L} é incluso e \texttt{R} é excluso.

\begin{itemize}
    \item \texttt{fill(v.begin(), v.end(), x)}: Preenche o vetor \texttt{v} com o valor \texttt{x} - $\mathcal{O}(n)$
    \item \texttt{sort(v.begin(), v.end())}: Ordena o vetor \texttt{v} - $\mathcal{O}(n \log n)$
    \item \texttt{reverse(v.begin(), v.end())}: Inverte o vetor \texttt{v} - $\mathcal{O}(n)$
    \item \texttt{accumulate(v.begin(), v.end(), 0)}: Soma todos os elementos do vetor \texttt{v} - $\mathcal{O}(n)$
    \item \texttt{max\_element(v.begin(), v.end())}: Retorna um iterador para o maior elemento do vetor \texttt{v} - $\mathcal{O}(n)$
    \item \texttt{min\_element(v.begin(), v.end())}: Retorna um iterador para o menor elemento do vetor \texttt{v} - $\mathcal{O}(n)$
    \item \texttt{count(v.begin(), v.end(), x)}: Retorna o número de ocorrências do elemento \texttt{x} no vetor \texttt{v} - $\mathcal{O}(n)$
    \item \texttt{find(v.begin(), v.end(), x)}: Retorna um iterador para a primeira ocorrência do elemento \texttt{x} no vetor \texttt{v}, ou \texttt{v.end()} se não existir - $\mathcal{O}(n)$
    I\item \texttt{lower\_bound(v.begin(), v.end(), x)}: Retorna um iterador para o primeiro elemento maior ou igual a \texttt{x} no vetor \texttt{v} (o vetor deve estar ordenado) - $\mathcal{O}(\log n)$
    \item \texttt{upper\_bound(v.begin(), v.end(), x)}: Retorna um iterador para o primeiro elemento estritamente maior que \texttt{x} no vetor \texttt{v} (o vetor deve estar ordenado) - $\mathcal{O}(\log n)$
    \item \texttt{next\_permutation(a.begin(), a.end())}: Rearranja os elementos do vetor \texttt{a} para a próxima permutação lexicograficamente maior - $\mathcal{O}(n)$
\end{itemize}

\section{Pragmas}

Os pragmas são diretivas para o compilador, que podem ser usadas para otimizar o código.

Temos os pragmas de otimização, como por exemplo:

\begin{itemize}
    \item \texttt{\#pragma GCC optimize("O2")}: Otimizações de nível 2 (padrão de competições)
    \item \texttt{\#pragma GCC optimize("O3")}: Otimizações de nível 3 (seguro para usar)
    \item \texttt{\#pragma GCC optimize("Ofast")}: Otimizações agressivas (perigoso!)
    \item \texttt{\#pragma GCC optimize("unroll-loops")}: Otimiza os loops mas pode levar a cache misses
\end{itemize}

E também os pragmas de target, que são usados para otimizar o código para um certo processador:

\begin{itemize}
    \item \texttt{\#pragma GCC target("avx2")}: Otimiza instruções para processadores com suporte a AVX2
    \item \texttt{\#pragma GCC target("sse4")}: Parecido com o de cima, mas mais antigo
    \item \texttt{\#pragma GCC target("popcnt")}: Otimiza o popcount em processadores que suportam
    \item \texttt{\#pragma GCC target("lzcnt")}: Otimiza o leading zero count em processadores que suportam
    \item \texttt{\#pragma GCC target("bmi")}: Otimiza instruções de bit manipulation em processadores que suportam
    \item \texttt{\#pragma GCC target("bmi2")}: Mesmo que o de cima, mas mais recente
\end{itemize}

Em geral, esses pragmas são usados para otimizar o código em competições, mas é importante usálos com certa sabedoria, em alguns casos eles podem piorar o desempenho do código.

Uma opção relativamente segura de se usar é a seguinte:

\begin{lstlisting}[language=C++]
    #pragma GCC optimize("O3,unroll-loops")
    #pragma GCC target("avx2,bmi,bmi2,lzcnt,popcnt")
\end{lstlisting}

\section{Constantes em C++}

\begin{center}
\begin{tabular}{|c|c|c|}
  \hline
  Constante & Nome em \texttt{C++} & Valor \\
  \hline
  $\pi$ & \texttt{M\_PI} & 3.141592... \\
  \hline
  $\pi / 2$ & \texttt{M\_PI\_2} & 1.570796... \\
  \hline
  $\pi / 4$ & \texttt{M\_PI\_4} & 0.785398... \\
  \hline
  $1 / \pi$ & \texttt{M\_1\_PI} & 0.318309... \\
  \hline
  $2 / \pi$ & \texttt{M\_2\_PI} & 0.636619... \\
  \hline
  $2 / \sqrt{\pi}$ & \texttt{M\_2\_SQRTPI} & 1.128379... \\
  \hline
  $\sqrt{2}$ & \texttt{M\_SQRT2} & 1.414213... \\
  \hline
  $1 / \sqrt{2}$ & \texttt{M\_SQRT1\_2} & 0.707106... \\
  \hline
  $e$ & \texttt{M\_E} & 2.718281... \\
  \hline
  $\log_2{e}$ & \texttt{M\_LOG2E} & 1.442695... \\
  \hline
  $\log_{10}{e}$ & \texttt{M\_LOG10E} & 0.434294... \\
  \hline
  $\ln{2}$ & \texttt{M\_LN2} & 0.693147... \\
  \hline
  $\ln{10}$ & \texttt{M\_LN10} & 2.302585... \\
  \hline
\end{tabular}
\end{center}
\chapter{Teórico}


\section {Definições}

Algumas definições e termos importantes:


\subsection{Funções}

\begin{itemize}
  \item \textbf{Comutativa}: Uma função $f(x, y)$ é comutativa se $f(x, y) = f(y, x)$.
  \item \textbf{Associativa}: Uma função $f(x, y)$ é associativa se $f(x, f(y, z)) = f(f(x, y), z)$.
  \item \textbf{Idempotente}: Uma função $f(x, y)$ é idempotente se $f(x, x) = x$.
\end{itemize}


\subsection{Grafos}

\begin{itemize}
  \item \textbf{Grafo}: Um grafo é um conjunto de vértices e um conjunto de arestas que conectam os vértices.
  \item \textbf{Grafo Conexo}: Um grafo é conexo se existe um caminho entre todos os pares de vértices.
  \item \textbf{Grafo Bipartido}: Um grafo é bipartido se é possível dividir os vértices em dois conjuntos disjuntos de forma que todas as arestas conectem um vértice de um conjunto com um vértice do outro conjunto, ou seja, não existem arestas que conectem vértices do mesmo conjunto.
  \item \textbf{Árvore}: Um grafo é uma árvore se ele é conexo e não possui ciclos.
  \item \textbf{Árvore Geradora Mínima (AGM)}: Uma árvore geradora mínima é uma árvore que conecta todos os vértices de um grafo e possui o menor custo possível, também conhecido como \textit{Minimum Spanning Tree (MST)}.
\end{itemize}


\section{Números primos}

Números primos são muito úteis para funções de hashing (dentre outras coisas). Aqui vão vários números primos interessantes:


\subsection{Primos com truncamento à esquerda}

Números primos tais que qualquer sufixo deles é um número primo:

\begin{center}
\LARGE
33,333,31 \\
\LARGE
357,686,312,646,216,567,629,137
\end{center}


\subsection{Primos gêmeos (Twin Primes)}

Pares de primos da forma $(p, p + 2)$ (aqui tem só alguns pares aleatórios, existem muitos outros).

\begin{table}[h]
  \centering
  \begin{tabular}{|c|c|c|}
    \hline
    \textbf{Primo} & \textbf{Primo + 2} & \textbf{Ordem} \\
    \hline
    5 & 7 & $10^0$ \\
    \hline
    17 & 19 & $10^1$ \\
    \hline
    461 & 463 & $10^2$ \\
    \hline
    3461 & 3463 & $10^3$ \\
    \hline
    34499 & 34501 & $10^4$ \\
    \hline
    487829 & 487831 & $10^5$ \\
    \hline
    5111999 & 5112001 & $10^6$ \\
    \hline
    30684887 & 30684889 & $10^7$ \\
    \hline
    361290539 & 361290541 & $10^8$ \\
    \hline
    1000000007 & 1000000009 & $10^9$ \\
    \hline
    1005599459 & 1005599461 & $10^9$ \\
    \hline
  \end{tabular}
\end{table}


\subsection{Números primos de Mersenne}

São os números primos da forma $2^m - 1$, onde $m$ é um número inteiro positivo.

\begin{table}[h]
  \centering
  \begin{tabular}{|c|c|}
    \hline
    \textbf{Expoente ($m$)} & \textbf{Representação Decimal} \\
    \hline
    \(2\) & 3 \\
    \hline
    \(3\) & 7 \\
    \hline
    \(5\) & 31 \\
    \hline
    \(7\) & 127 \\
    \hline
    \(13\) & 8,191 \\
    \hline
    \(17\) & 131,071 \\
    \hline
    \(19\) & 524,287 \\
    \hline
    \(31\) & 2,147,483,647 \\
    \hline
    \(61\) & $2,3 * 10^{18}$ \\
    \hline
    \(89\) & $6,1 * 10^{26}$ \\
    \hline
    \(107\) & $1,6 * 10^{32}$ \\
    \hline
    \(127\) & $1,7 * 10^{38}$ \\
    \hline
  \end{tabular}
\end{table}


\section{Operadores lineares}


\subsection{Rotação no sentido anti-horário por $\theta ^\circ$}

\begin{equation*} 
\large
\begin{bmatrix}
    \cos \theta & -\sin \theta \\
    \sin \theta & \cos \theta
\end{bmatrix}
\end{equation*}


\subsection{Reflexão em relação à reta $y = mx$ }

\begin{equation*}
\large
\frac{1}{m^2+1} 
\begin{bmatrix}
    1 - m^2 & 2m \\
    2m & m^2 - 1
\end{bmatrix}
\end{equation*} 


\subsection{Inversa de uma matriz 2x2 A}

\begin{equation*} 
\large 
\begin{bmatrix}
    a & b \\
    c & d
\end{bmatrix}^{-1} =
\frac{1}{\text{det}(A)}
\begin{bmatrix}
    d & -b \\
    -c & a
\end{bmatrix}
\end{equation*}


\subsection{Cisalhamento horizontal por K}

\begin{equation*} 
\large
\begin{bmatrix}
    1 & K \\
    0 & 1
\end{bmatrix}
\end{equation*}


\subsection{Cisalhamento vertical por K}

\begin{equation*} 
\large
\begin{bmatrix}
    1 & 0 \\
    K & 1
\end{bmatrix}
\end{equation*}


\subsection{Mudança de base}

{\large $\vec{a}_\beta$ são as coordenadas do vetor $\vec{a}$ na base $\beta$.\\}
{\large $\vec{a}$ são as coordenadas do vetor $\vec{a}$ na base canônica.\\}
{\large $\vec{b1}$ e $\vec{b2}$ são os vetores de base para $\beta$.\\}
{\large $C$ é uma matriz que muda da base $\beta$ para a base canônica.}

\begin{equation*}
\large C \vec{a}_\beta = \vec{a}
\end{equation*} 
\begin{equation*}
\large C^{-1} \vec{a} = \vec{a}_\beta
\end{equation*} 
\begin{equation*} 
\large
C = 
\begin{bmatrix}
    b1_x & b2_x \\
    b1_y & b2_y
\end{bmatrix}
\end{equation*}


\subsection{Propriedades das operações de matriz}

\begin{equation*} 
\large (AB)^{-1} = A^{-1}B^{-1}\\
\end{equation*}
\begin{equation*} 
\large (AB)^{T} = B^{T}A^{T} \\
\end{equation*}
\begin{equation*} 
\large (A^{-1})^{T} = (A^{T})^{-1} \\
\end{equation*}
\begin{equation*} 
\large (A+B)^{T} = A^{T} + B^{T} \\
\end{equation*}
\begin{equation*} 
\large \text{det}(A) = \text{det}(A^{T}) \\
\end{equation*}
\begin{equation*} 
\large \text{det}(AB) = \text{det}(A)\text{det}(B) \\
\end{equation*}
{\large Seja $A$ uma matriz NxN:}
\begin{equation*} 
\large \text{det}(kA) = K^N\text{det}(A) \\
\end{equation*}

\section{Sequências numéricas}

\subsection{Sequência de Fibonacci}

Primeiros termos: \textbf{1, 1, 2, 3, 5, 8, 13, 21, 34, \ldots}

Definição:

\begin{equation*}
\large
F_0 = F_1 = 1
\end{equation*}

\begin{equation*}
\large
F_n = F_{n-1} + F_{n-2}
\end{equation*}

Matriz de recorrência:

\begin{equation*}
\large
\begin{bmatrix}
    0 & 1 \\
    1 & 1
\end{bmatrix}
\begin{bmatrix}
    F_{n-2} \\
    F_{n-1}
\end{bmatrix}
=
\begin{bmatrix}
    F_{n-1} \\
    F_n
\end{bmatrix}
\end{equation*}

\subsection{Sequência de Catalan}

Primeiros termos: \textbf{1, 1, 2, 5, 14, 42, 132, 429, 1430, \ldots}

Definição:

\begin{equation*}
\large
C_0 = C_1 = 1
\end{equation*}

\begin{equation*}
\large
C_n = \sum_{i=0}^{n-1} C_i \cdot C_{n-1-i}
\end{equation*}

Definição analítica:

\begin{equation*}
\large
C_n = \frac{1}{n+1} \binom{2n}{n}
\end{equation*}

Propriedades úteis:

\begin{itemize}
  \item $C_n$ é o número de árvores binárias com $n+1$ folhas.
  \item $C_n$ é o número de sequências de parênteses bem formadas com $n$ pares de parênteses.
\end{itemize}

\section{Análise combinatória}

\subsection{Fatorial}

O fatorial de um número $n$ é o produto de todos os inteiros positivos menores ou iguais a $n$.

O fatorial conta o número de permutações de $n$ elementos.

\begin{equation*}
\large
n! = n \cdot (n-1)!
\end{equation*}

Em particular, $0! = 1$.

\subsection{Combinação}

Conta o número de maneiras de escolher $k$ elementos de um conjunto de $n$ elementos.

\begin{equation*}
\large
\binom{n}{k} = \frac{n!}{k! \cdot (n-k)!}
\end{equation*}

\subsection{Arranjo}

Conta o número de maneiras de escolher $k$ elementos de um conjunto de $n$ elementos, onde a ordem importa.

\begin{equation*}
\large
P(n, k) = \frac{n!}{(n-k)!}
\end{equation*}

\subsection{Estrelas e barras}

Conta o número de maneiras de distribuir $n$ elementos idênticos em $k$ recipientes distintos.

\begin{equation*}
\large
\binom{n+k-1}{k-1}
\end{equation*}

\subsection{Princípio da inclusão-exclusão}

O princípio da inclusão-exclusão é uma técnica para contar o número de elementos em uma união de conjuntos.

\begin{equation*}
\large
\left| \bigcup_{i=1}^{n} A_i \right| = \sum_{k=1}^{n} (-1)^{k+1} \left( \sum_{1 \leq i_1 < i_2 < \ldots < i_k \leq n} \left| A_{i_1} \cap A_{i_2} \cap \ldots \cap A_{i_k} \right| \right)
\end{equation*}

\subsection{Princípio da casa dos pombos}

Se $n$ pombos são colocados em $m$ casas, então pelo menos uma casa terá $\lceil \frac{n}{m} \rceil$ pombos ou mais.

\section{Teoria dos números}

\subsection{Pequeno teorema de Fermat}

Se $p$ é um número primo e $a$ é um inteiro não divisível por $p$, então $a^{p-1} \equiv 1 \pmod{p}$.

\subsection{Teorema de Euler}

Se $m$ e $a$ são inteiros positivos coprimos, então $a^{\phi(m)} \equiv 1 \pmod{m}$, onde $\phi(m)$ é a função totiente de Euler.

\subsection{Aritmética modular}

Quando estamos trabalhando com aritmética módulo um número $p$, todos os valores existentes estão entre $[0, p-1]$. 

Algumas propriedades e equivalências úteis para usar aritmética modular em código são:

\begin{itemize}
  \item $(a + b) \mod p \equiv ((a \mod p) + (b \mod p)) \mod p$
  \item $(a - b) \mod p \equiv ((a \mod p) - (b \mod p)) \mod p$
  \begin{itemize}
    \item Note que o resultado pode ser negativo, nesse é necessário adicionar $p$ ao resultado. De forma geral, geralmente fazemos $(a - b + p) \mod p$ (assumindo que $a$ e $b$ já estão no intervalo $[0, p-1]$).
  \end{itemize}
  \item $(a \cdot b) \mod p \equiv ((a \mod p) \cdot (b \mod p)) \mod p$
  \item $a^b \mod p \equiv ((a \mod p)^b) \mod p$
  \item $a^b \mod p \equiv ((a \mod p)^{(b \mod \phi(p))}) \mod p$ se $a$ e $p$ são coprimos
\end{itemize}
\newpage

%%%%%%
%
%
% Extra
%
%
%%%%%%

\chapter{Extra}

\section{CPP}


Template de C++ para usar na Maratona.
\hfill

Codigo: template.cpp

\begin{lstlisting}[language=C++]
#include <bits/stdc++.h>
#define endl '\n'
using namespace std;
using ll = long long;

void solve() { }

signed main() {
    cin.tie(0)->sync_with_stdio(0);
    solve();
}
\end{lstlisting}
\hfill

\section{Debug}


Template para debugar variáveis em \texttt{C++}. Até a linha 17 é opcional, é pra permitir que seja possível debugar \texttt{std::pair} e \texttt{std::vector}.

Para usar, basta compilar com a flag \texttt{-DBRUTE} (o template \texttt{run} já tem essa flag). E no código usar \texttt{debug(x, y, z)} para debugar as variáveis \texttt{x}, \texttt{y} e \texttt{z}.
\hfill

Codigo: debug.cpp

\begin{lstlisting}[language=C++]
template <typename T, typename U>
ostream &operator<<(ostream &os, const pair<T, U> &p) { // opcional
    os << "(" << p.first << ", " << p.second << ")";
    return os;
}
template <typename T>
ostream &operator<<(ostream &os, const vector<T> &v) { // opcional
    os << "{";
    int n = (int)v.size();
    for (int i = 0; i < n; i++) {
        os << v[i];
        if (i < n - 1) os << ", ";
    }
    os << "}";
    return os;
}

void _print() { }
template <typename T, typename... U>
void _print(T a, U... b) {
    if (sizeof...(b)) {
        cerr << a << ", ";
        _print(b...);
    } else cerr << a;
}
#ifdef BRUTE
#define debug(x...) cerr << "[" << #x << "] = [", _print(x), cerr << "]" << endl
#else
#define debug(...)
#endif\end{lstlisting}
\hfill

\section{Random}


É possível usar a função \texttt{rand()} para gerar números aleatórios em \texttt{C++}.

Útil para gerar casos aleatórios em stress test, porém não é recomendado para usar em soluções.

\texttt{rand()} gera números entre \texttt{0} e \texttt{RAND\_MAX} (que é pelo menos \texttt{32767}), mas costuma ser \texttt{2147483647} (depende do sistema/arquitetura).

Para usar o \texttt{rand()}, recomenda-se no mínimo chamar a função \texttt{srand(time(0))} no início da \texttt{main()} para inicializar a seed do gerador de números aleatórios.



Para usar números aleatórios em soluções, recomenda-se o uso do \texttt{mt19937} que está no código abaixo.

A função \texttt{rng()} gera números entre \texttt{0} e \texttt{UINT\_MAX} (que é \texttt{4294967295}).

Para gerar números aleatórios de 64 bits, usar \texttt{mt19937\_64} como tipo do \texttt{rng}.

Recomenda-se o uso da função \texttt{uniform(l, r)} para gerar números aleatórios no intervalo fechado $[l, r]$ usando o \texttt{mt19937}.

\hfill

Codigo: rand.cpp

\begin{lstlisting}[language=C++]
mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());

int uniform(int l, int r) { return uniform_int_distribution<int>(l, r)(rng); }
\end{lstlisting}
\hfill

\section{Run}


Arquivo útil para compilar e rodar um programa em \texttt{C++} com flags que ajudam a debugar.

Basta criar um arquivo chamado \texttt{run}, adicionar o código abaixo e dar permissão de execução com \texttt{chmod +x run}.

Para executar um arquivo \texttt{a.cpp}, basta rodar \texttt{./run a.cpp}.

\hfill

Codigo: run

\begin{lstlisting}[language=C++]
#!/bin/bash
g++ -std=c++20 -DBRUTE -O2 -Wall -Wextra -Wconversion -Wfatal-errors -fsanitize=address,undefined $1 && ./a.out\end{lstlisting}
\hfill

\section{Stress Test}


Script muito útil para achar casos em que sua solução gera uma resposta incorreta.

Deve-se criar uma solução bruteforce (que garantidamente está correta, ainda que seja lenta) e um gerador de casos aleatórios para seu problema.
\hfill

Codigo: stress.sh

\begin{lstlisting}[language=C++]
#!/bin/bash
set -e

g++ -O2 gen.cpp -o gen # pode fazer o gerador em python se preferir
g++ -O2 brute.cpp -o brute
g++ -O2 code.cpp -o code

for((i = 1; ; ++i)); do
    ./gen $i > in
    ./code < in > out
    ./brute < in > ok
    diff -w out ok || break
    echo "Passed test: " $i
done

echo "WA no seguinte teste:"
cat in
echo "Sua resposta eh:"
cat out
echo "A resposta correta eh:"
cat ok\end{lstlisting}
\hfill

\section{Unordered Custom Hash}


As funções de hash padrão do \texttt{unordered\_map} e \texttt{unordered\_set} são muito propícias a colisões (principalmente se o setter da questão criar casos de teste pensando nisso).

Para evitar isso, é possível criar uma função de hash customizada.



Entretanto, é bem raro ser necessário usar isso. Geralmente o fator $\mathcal{O}(\log n)$ de um \texttt{map} é suficiente.



Exemplo de uso: \texttt{unordered\_map<int, int, custom\_hash> mp;}
\hfill

Codigo: custom\_hash.cpp

\begin{lstlisting}[language=C++]
struct custom_hash {
    static uint64_t splitmix64(uint64_t x) {
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM =
            chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};\end{lstlisting}
\hfill

\section{Vim}


Template de arquivo \texttt{.vimrc} para configuração do Vim.

\hfill

Codigo: vimrc

\begin{lstlisting}[language=C++]
set nu ai si cindent et ts=4 sw=4 so=10 nosm

inoremap {} {}<left><return><up><end><return> " remap pra chaves

au BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$") | exe "normal! g'\"" | endif " volta pro lugar onde estava quando saiu do arquivo
\end{lstlisting}
\hfill

\newpage

%%%%%%
%
%
% Estruturas de Dados
%
%
%%%%%%

\chapter{Estruturas de Dados}

\section{Disjoint Set Union}
\subsection{DSU}


Estrutura que mantém uma coleção de conjuntos e permite as operações de unir dois conjuntos e verificar em qual conjunto um elemento está, ambas em $\mathcal{O}(1)$ amortizado. O método \texttt{find} retorna o representante do conjunto que contém o elemento, e o método \texttt{unite} une os conjuntos que contém os elementos dados, retornando \texttt{true} se eles estavam em conjuntos diferentes e \texttt{false} caso contrário.

\hfill

Codigo: dsu.cpp

\begin{lstlisting}[language=C++]
struct DSU {
    vector<int> par, sz;
    int number_of_sets;
    DSU(int n = 0) : par(n), sz(n, 1), number_of_sets(n) {
        iota(par.begin(), par.end(), 0);
    }
    int find(int a) { return a == par[a] ? a : par[a] = find(par[a]); }
    bool unite(int a, int b) {
        a = find(a), b = find(b);
        if (a == b) return false;
        number_of_sets--;
        if (sz[a] < sz[b]) swap(a, b);
        par[b] = a;
        sz[a] += sz[b];
        return true;
    }
};
\end{lstlisting}
\hfill

\subsection{DSU Bipartido}


DSU que mantém se um conjunto é bipartido (visualize os conjuntos como componentes conexas de um grafo e os elementos como nodos). O método $unite$ adiciona uma aresta entre os dois elementos dados, e retorna \texttt{true} se os elementos estavam em conjuntos diferentes (componentes conexas diferentes) e \texttt{false} caso contrário. O método \texttt{bipartite} retorna \texttt{true} se o conjunto (componente conexa) que contém o elemento dado é bipartido e \texttt{false} caso contrário. Todas as operações são $\mathcal{O}(\log n)$.

\hfill

Codigo: bipartite\_dsu.cpp

\begin{lstlisting}[language=C++]
struct Bipartite_DSU {
    vector<int> par, sz, c, bip;
    int number_of_sets, all_bipartite;
    Bipartite_DSU(int n = 0)
        : par(n), sz(n, 1), c(n), bip(n, 1), number_of_sets(n), all_bipartite(1) {
        iota(par.begin(), par.end(), 0);
    }
    int find(int a) { return a == par[a] ? a : find(par[a]); }
    int color(int a) { return a == par[a] ? c[a] : c[a] ^ color(par[a]); }
    bool bipartite(int a) { return bip[find(a)]; }
    bool unite(int a, int b) {
        bool equal_color = color(a) == color(b);
        a = find(a), b = find(b);
        if (a == b) {
            if (equal_color) {
                bip[a] = 0;
                all_bipartite = 0;
            }
            return false;
        }
        if (sz[a] < sz[b]) swap(a, b);
        number_of_sets--;
        par[b] = a;
        sz[a] += sz[b];
        if (equal_color) c[b] = 1;
        bip[a] &= bip[b];
        all_bipartite &= bip[a];
        return true;
    }
};
\end{lstlisting}
\hfill

\subsection{DSU Rollback}


DSU que desfaz as últimas operações. O método \texttt{checkpoint} salva o estado atual da estrutura, e o método \texttt{rollback} desfaz as últimas operações até o último checkpoint. As operações de unir dois conjuntos e verificar em qual conjunto um elemento está são $\mathcal{O}(\log n)$, o rollback é $\mathcal{O}(k)$, onde $k$ é o número de alterações a serem desfeitas e o \texttt{checkpoint} é $\mathcal{O}(1)$. Importante notar que o rollback não altera a complexidade de uma solução, uma vez que $\sum k = \mathcal{O}(q)$, onde $q$ é o número de operações realizadas.

\hfill

Codigo: rollback\_dsu.cpp

\begin{lstlisting}[language=C++]
struct Rollback_DSU {
    vector<int> par, sz;
    int number_of_sets;
    stack<stack<pair<int &, int>>> changes;
    Rollback_DSU(int n = 0) : par(n), sz(n, 1), number_of_sets(n) {
        iota(par.begin(), par.end(), 0);
        changes.emplace();
    }
    int find(int a) { return a == par[a] ? a : find(par[a]); }
    void checkpoint() { changes.emplace(); }
    void change(int &a, int b) {
        changes.top().emplace(a, a);
        a = b;
    }
    bool unite(int a, int b) {
        a = find(a), b = find(b);
        if (a == b) return false;
        if (sz[a] < sz[b]) swap(a, b);
        change(number_of_sets, number_of_sets - 1);
        change(par[b], a);
        change(sz[a], sz[a] + sz[b]);
        return true;
    }
    void rollback() {
        while (changes.top().size()) {
            auto [a, b] = changes.top().top();
            a = b;
            changes.top().pop();
        }
        changes.pop();
    }
};\end{lstlisting}
\hfill

\subsection{DSU Rollback Bipartido}


DSU com rollback e bipartido.

\hfill

Codigo: bipartite\_rollback\_dsu.cpp

\begin{lstlisting}[language=C++]
struct BipartiteRollback_DSU {
    vector<int> par, sz, c, bip;
    int number_of_sets, all_bipartite;
    stack<stack<pair<int &, int>>> changes;
    BipartiteRollback_DSU(int n = 0)
        : par(n), sz(n, 1), c(n), bip(n, 1), number_of_sets(n), all_bipartite(1) {
        iota(par.begin(), par.end(), 0);
        changes.emplace();
    }
    int find(int a) { return a == par[a] ? a : find(par[a]); }
    int color(int a) { return a == par[a] ? c[a] : c[a] ^ color(par[a]); }
    bool bipartite(int a) { return bip[find(a)]; }
    void checkpoint() { changes.emplace(); }
    void change(int &a, int b) {
        changes.top().emplace(a, a);
        a = b;
    }
    bool unite(int a, int b) {
        bool equal_color = color(a) == color(b);
        a = find(a), b = find(b);
        if (a == b) {
            if (equal_color) {
                change(bip[a], 0);
                change(all_bipartite, 0);
            }
            return false;
        }
        if (sz[a] < sz[b]) swap(a, b);
        change(number_of_sets, number_of_sets - 1);
        change(par[b], a);
        change(sz[a], sz[a] + sz[b]);
        change(bip[a], bip[a] && bip[b]);
        change(all_bipartite, all_bipartite && bip[a]);
        if (equal_color) change(c[b], 1);
        return true;
    }
    void rollback() {
        while (changes.top().size()) {
            auto [a, b] = changes.top().top();
            a = b;
            changes.top().pop();
        }
        changes.pop();
    }
};\end{lstlisting}
\hfill

\subsection{Offline DSU}


Algoritmo que utiliza o DSU com Rollback e Bipartido que permite adição e \textbf{remoção} de arestas. O algoritmo funciona de maneira offline, recebendo previamente todas as operações de adição e remoção de arestas, bem como todas as perguntas (de qualquer tipo, conectividade, bipartição, etc), e retornando as respostas para cada pergunta no retorno do método \texttt{solve}. Complexidade total $\mathcal{O}(q\cdot(\log q + \log n))$, onde $q$ é o número de operações realizadas e $n$ é o número de nodos.

\hfill

Codigo: offline\_dsu.cpp

\begin{lstlisting}[language=C++]
struct Offline_DSU : BipartiteRollback_DSU {
    int time;
    Offline_DSU(int n = 0) : BipartiteRollback_DSU(n), time(0) { }
    struct query {
        int type, a, b;
    };
    vector<query> queries;
    void askConnect(int a, int b) {
        if (a > b) swap(a, b);
        queries.push_back({0, a, b});
        time++;
    }
    void askBipartite(int a) {
        queries.push_back({1, a, -1});
        time++;
    }
    void askAllBipartite() {
        queries.push_back({2, -1, -1});
        time++;
    }
    void addEdge(int a, int b) {
        if (a > b) swap(a, b);
        queries.push_back({3, a, b});
        time++;
    }
    void removeEdge(int a, int b) {
        if (a > b) swap(a, b);
        queries.push_back({4, a, b});
        time++;
    }
    vector<vector<pair<int, int>>> lazy;
    void update(int l, int r, pair<int, int> edge, int u, int L, int R) {
        if (R < l || L > r) return;
        if (L >= l && R <= r) {
            lazy[u].push_back(edge);
            return;
        }
        int mid = (L + R) / 2;
        update(l, r, edge, 2 * u, L, mid);
        update(l, r, edge, 2 * u + 1, mid + 1, R);
    }
    void dfs(int u, int L, int R, vector<int> &ans) {
        if (L > R) return;
        checkpoint();
        for (auto [a, b] : lazy[u]) unite(a, b);
        if (L == R) {
            auto [type, a, b] = queries[L];
            if (type == 0) ans.push_back(find(a) == find(b));
            else if (type == 1) ans.push_back(bipartite(a));
            else if (type == 2) ans.push_back(all_bipartite);
        } else {
            int mid = (L + R) / 2;
            dfs(2 * u, L, mid, ans);
            dfs(2 * u + 1, mid + 1, R, ans);
        }
        rollback();
    }
    vector<int> solve() {
        lazy.assign(4 * time, {});
        map<pair<int, int>, int> edges;
        for (int i = 0; i < time; i++) {
            auto [type, a, b] = queries[i];
            if (type == 3) {
                edges[{a, b}] = i;
            } else if (type == 4) {
                update(edges[{a, b}], i, {a, b}, 1, 0, time - 1);
                edges.erase({a, b});
            }
        }
        for (auto [k, v] : edges) update(v, time - 1, k, 1, 0, time - 1);
        vector<int> ans;
        dfs(1, 0, time - 1, ans);
        return ans;
    }
};\end{lstlisting}
\hfill

\section{Fenwick Tree}
\subsection{Fenwick}


Árvore de Fenwick (ou BIT) é uma estrutura de dados que permite atualizações pontuais e consultas de prefixos em um vetor em $\mathcal{O}(\log n)$. A implementação abaixo é 0-indexada (é mais comum encontrar a implementação 1-indexada). A consulta em ranges arbitrários com o método \texttt{query} é possível para qualquer operação inversível, como soma, XOR, multiplicação, etc. A implementação abaixo é para soma, mas é fácil adaptar para outras operações. O método \texttt{update} soma $d$ à posição $i$ do vetor, enquanto o método \texttt{updateSet} substitue o valor da posição $i$ do vetor por $d$.

\hfill

Codigo: fenwick\_tree.cpp

\begin{lstlisting}[language=C++]
template <typename T>
struct FenwickTree {
    int n;
    vector<T> bit, arr;
    FenwickTree(int _n = 0) : n(_n), bit(n), arr(n) { }
    FenwickTree(vector<T> &v) : n(int(v.size())), bit(n), arr(v) {
        for (int i = 0; i < n; i++) bit[i] = arr[i];
        for (int i = 0; i < n; i++) {
            int j = i | (i + 1);
            if (j < n) bit[j] = bit[j] + bit[i];
        }
    }
    T pref(int x) {
        T res = T();
        for (int i = x; i >= 0; i = (i & (i + 1)) - 1) res = res + bit[i];
        return res;
    }
    T query(int l, int r) {
        if (l == 0) return pref(r);
        return pref(r) - pref(l - 1);
    }
    void update(int x, T d) {
        for (int i = x; i < n; i = i | (i + 1)) bit[i] = bit[i] + d;
        arr[x] = arr[x] + d;
    }
    void updateSet(int i, T d) {
        // funciona pra fenwick de soma
        update(i, d - arr[i]);
        arr[i] = d;
    }
};
\end{lstlisting}
\hfill

\subsection{Kd Fenwick Tree}


Fenwick Tree em $k$ dimensões. Faz apenas queries de prefixo e updates pontuais em $\mathcal{O}(k \cdot \log^k n)$. Para queries em range, deve-se fazer inclusão-exclusão, porém a complexidade fica exponencial, para $k$ dimensões a query em range é $\mathcal{O}(2^k \cdot k \cdot \log^k n)$.

\hfill

Codigo: kd\_fenwick\_tree.cpp

\begin{lstlisting}[language=C++]
const int MAX = 20;
long long tree[MAX][MAX][MAX][MAX]; // insira o numero de dimensoes aqui

long long query(vector<int> s, int pos = 0) { // s eh a coordenada
    long long sum = 0;
    while (s[pos] >= 0) {
        if (pos < (int)s.size() - 1) {
            sum += query(s, pos + 1);
        } else {
            sum += tree[s[0]][s[1]][s[2]][s[3]];
            // atualizar se mexer no numero de dimensoes
        }
        s[pos] = (s[pos] & (s[pos] + 1)) - 1;
    }
    return sum;
}

void update(vector<int> s, int v, int pos = 0) {
    while (s[pos] < MAX) {
        if (pos < (int)s.size() - 1) {
            update(s, v, pos + 1);
        } else {
            tree[s[0]][s[1]][s[2]][s[3]] += v;
            // atualizar se mexer no numero de dimensoes
        }
        s[pos] |= s[pos] + 1;
    }
}\end{lstlisting}
\hfill

\section{Interval Tree}


\textbf{Por Rafael Granza de Mello}



Estrutura que trata intersecções de intervalos.



Capaz de retornar todos os intervalos que intersectam $[L, R]$. Contém métodos \texttt{insert({L, R, ID})}, \texttt{erase({L, R, ID})}, \texttt{overlaps(L, R)} e \texttt{find({L, R, ID})}. É necessário inserir e apagar indicando tanto os limites quanto o ID do intervalo. Todas as operações são $\mathcal{O}(\log n)$, exceto \texttt{overlaps} que é $\mathcal{O}(k + \log n)$, onde $k$ é o número de intervalos que intersectam $[L, R]$. Também podem ser usadas as operações padrões de um \texttt{std::set}

\hfill

Codigo: interval\_tree.cpp

\begin{lstlisting}[language=C++]
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;

struct interval {
    long long lo, hi, id;
    bool operator<(const interval &i) const {
        return tuple(lo, hi, id) < tuple(i.lo, i.hi, i.id);
    }
};

const long long INF = 1e18;

template <class CNI, class NI, class Cmp_Fn, class Allocator>
struct intervals_node_update {
    typedef long long metadata_type;
    int sz = 0;
    virtual CNI node_begin() const = 0;
    virtual CNI node_end() const = 0;
    inline vector<int> overlaps(const long long l, const long long r) {
        queue<CNI> q;
        q.push(node_begin());
        vector<int> vec;
        while (!q.empty()) {
            CNI it = q.front();
            q.pop();
            if (it == node_end()) continue;
            if (r >= (*it)->lo && l <= (*it)->hi) vec.push_back((*it)->id);
            CNI l_it = it.get_l_child();
            long long l_max = (l_it == node_end()) ? -INF : l_it.get_metadata();
            if (l_max >= l) q.push(l_it);
            if ((*it)->lo <= r) q.push(it.get_r_child());
        }
        return vec;
    }
    inline void operator()(NI it, CNI end_it) {
        const long long l_max =
            (it.get_l_child() == end_it) ? -INF : it.get_l_child().get_metadata();
        const long long r_max =
            (it.get_r_child() == end_it) ? -INF : it.get_r_child().get_metadata();
        const_cast<long long &>(it.get_metadata()) = max((*it)->hi, max(l_max, r_max));
    }
};
typedef tree<interval, null_type, less<interval>, rb_tree_tag, intervals_node_update>
    interval_tree;
\end{lstlisting}
\hfill

\section{LiChao Tree}


Uma árvore de funções. Retorna o $f(x)$ máximo em um ponto $x$.



Para retornar o minimo deve-se inserir o negativo da função ($g(x) = -ax - b$) e pegar o negativo do resultado. Ou, alterar a função de comparação da árvore se souber mexer.



Funciona para funções com a seguinte propriedade, sejam duas funções $f(x)$ e $g(x)$, uma vez que $f(x)$ passa a ganhar/perder pra $g(x)$, $f(x)$ nunca mais passa a perder/ganhar pra $g(x)$. Em outras palavras, $f(x)$ e $g(x)$ se intersectam no máximo uma vez.



Essa implementação está pronta para usar função linear do tipo $f(x) = ax + b$.



Sendo $L$ o tamanho do intervalo, a complexidade de consulta e inserção de funções é $\mathcal{O}(\log L)$.



\textbf{Dica}: No construtor da LiChao Tree, fazer \texttt{tree.reserve(MAX); L.reserve(MAX); R.reserve(MAX);} pode ajudar bastante no runtime, pois aloca espaço para os vetores e evita muitas realocações durante a execução. Nesse caso, \texttt{MAX} é geralmente $\mathcal{O}(Q \cdot \log L)$, onde $Q$ é o número de queries e $L$ é o tamanho do intervalo.
\hfill

Codigo: lichao\_tree.cpp

\begin{lstlisting}[language=C++]
template <ll MINL = ll(-1e9 - 5), ll MAXR = ll(1e9 + 5)>
struct LichaoTree {
    const ll INF = ll(2e18) + 10;
    struct Line {
        ll a, b;
        Line(ll a_ = 0, ll b_ = -INF) : a(a_), b(b_) { }
        ll operator()(ll x) { return a * x + b; }
    };
    vector<Line> tree;
    vector<int> L, R;

    int newnode() {
        tree.push_back(Line());
        L.push_back(-1);
        R.push_back(-1);
        return int(tree.size()) - 1;
    }

    LichaoTree() { newnode(); }

    int le(int u) {
        if (L[u] == -1) L[u] = newnode();
        return L[u];
    }

    int ri(int u) {
        if (R[u] == -1) R[u] = newnode();
        return R[u];
    }

    void insert(Line line, int n = 0, ll l = MINL, ll r = MAXR) {
        ll mid = (l + r) / 2;
        bool bl = line(l) > tree[n](l);
        bool bm = line(mid) > tree[n](mid);
        bool br = line(r) > tree[n](r);
        if (bm) swap(tree[n], line);
        if (line.b == -INF) return;
        if (bl != bm) insert(line, le(n), l, mid - 1);
        else if (br != bm) insert(line, ri(n), mid + 1, r);
    }

    ll query(int x, int n = 0, ll l = MINL, ll r = MAXR) {
        if (tree[n](x) == -INF || (l > r)) return -INF;
        if (l == r) return tree[n](x);
        ll mid = (l + r) / 2;
        if (x < mid) return max(tree[n](x), query(x, le(n), l, mid - 1));
        else return max(tree[n](x), query(x, ri(n), mid + 1, r));
    }
};
\end{lstlisting}
\hfill

\section{Merge Sort Tree}
\subsection{Merge Sort Tree}


Árvore muito semelhante a uma Segment Tree, mas ao invés de armazenar um valor em cada nodo, armazena um vetor ordenado. Permite realizar consultas do tipo: \texttt{count(L, R, A, B)} que retorna quantos elementos no intervalo $[L, R]$ estão no intervalo $[A, B]$ em $\mathcal{O}(\log^2 N)$. Em outras palavras, count(L, R, A, B) retorna quantos elementos $X$ existem no intervalo $[L, R]$ tal que $A \leq X \leq B$.



\textbf{Obs}: o método \texttt{kth} presente nessa implementação encontra o k-ésimo elemento no intervalo $[L, R]$ em $\mathcal{O}(\log^3 N)$. É possível otimizar esse método para $\mathcal{O}(\log^2 N)$, basta se criar um vetor que possui pares da forma \texttt{[A[i], i]} e ordená-lo de acordo com o valor de \texttt{A[i]}, agora, construa a Merge Sort Tree com esse vetor e no merge faça a união mantendo os valores de \texttt{i} ordenados. Dessa forma, sua Merge Sort Tree guardará em um nodo que representa o intervalo $[L, R]$ os índices ordenados de todos os elementos que estão entre o $(L + 1)$-ésimo e o $(R + 1)$-ésimo menor elemento do vetor original. Assim, para encontrar o k-ésimo elemento no intervalo $[L, R]$ basta fazer uma busca binária semelhante a busca binária de encontrar $k$-ésimo menor elemento em uma Segment Tree.
\hfill

Codigo: mergesort\_tree.cpp

\begin{lstlisting}[language=C++]
template <typename T = int>
struct MergeSortTree {
    vector<vector<T>> tree;
    int n;
    int le(int u) { return u << 1; }
    int ri(int u) { return u << 1 | 1; }
    void build(int u, int l, int r, const vector<T> &a) {
        tree[u] = vector<T>(r - l + 1);
        if (l == r) {
            tree[u][0] = a[l];
            return;
        }
        int mid = (l + r) >> 1;
        build(le(u), l, mid, a);
        build(ri(u), mid + 1, r, a);
        merge(
            tree[le(u)].begin(),
            tree[le(u)].end(),
            tree[ri(u)].begin(),
            tree[ri(u)].end(),
            tree[u].begin()
        );
    }
    void build(const vector<T> &a) { // para construir com vector
        n = (int)a.size();
        tree.assign(4 * n, vector<T>());
        build(1, 0, n - 1, a);
    }
    void build(T *bg, T *en) { // para construir com array de C
        build(vector<T>(bg, en));
    }
    int count(int u, int l, int r, int L, int R, int a, int b) {
        if (l > R || r < L || a > b) return 0;
        if (l >= L && r <= R) {
            auto ub = upper_bound(tree[u].begin(), tree[u].end(), b);
            auto lb = upper_bound(tree[u].begin(), tree[u].end(), a - 1);
            return (int)(ub - lb);
        }
        int mid = (l + r) >> 1;
        return count(le(u), l, mid, L, R, a, b) + count(ri(u), mid + 1, r, L, R, a, b);
    }
    int count(int l, int r, int a, int b) { return count(1, 0, n - 1, l, r, a, b); }
    int less(int l, int r, int k) { return count(l, r, tree[1][0], k - 1); }
    int kth(int l, int r, int k) {
        int L = 0, R = n - 1;
        int ans = -1;
        while (L <= R) {
            int mid = (L + R) >> 1;
            if (count(l, r, tree[1][0], tree[1][mid]) > k) {
                ans = mid;
                R = mid - 1;
            } else {
                L = mid + 1;
            }
        }
        return tree[1][ans];
    }
};
\end{lstlisting}
\hfill

\subsection{Merge Sort Tree Update}


Merge Sort Tree com updates pontuais. O update é $\mathcal{O}(\log^2 N)$ e a query é $\mathcal{O}(\log^2 N)$, ambos com constante alta.



\textbf{Obs}: usa a estrutura \texttt{ordered\_set}, descrita nesse Almanaque também.
\hfill

Codigo: mergesort\_tree\_update.cpp

\begin{lstlisting}[language=C++]
template <typename T = int>
struct MergeSortTree {
    vector<ordered_set<pair<T, int>>> tree;
    vector<T> v;
    int n;
    int le(int u) { return u << 1; }
    int ri(int u) { return u << 1 | 1; }
    void build(int u, int l, int r, const vector<T> &a) {
        if (l == r) {
            tree[u].insert({a[l], l});
            return;
        }
        int mid = (l + r) >> 1;
        build(le(u), l, mid, a);
        build(ri(u), mid + 1, r, a);
        for (auto x : tree[le(u)]) tree[u].insert(x);
        for (auto x : tree[ri(u)]) tree[u].insert(x);
    }
    void build(const vector<T> &a) { // para construir com vector
        n = (int)a.size();
        v = a;
        tree.assign(4 * n, ordered_set<pair<T, int>>());
        build(1, 0, n - 1, a);
    }
    void build(T *bg, T *en) { // para construir com array de C
        build(vector<T>(bg, en));
    }
    int count(int u, int l, int r, int L, int R, int a, int b) {
        if (l > R || r < L || a > b) return 0;
        if (l >= L && r <= R) {
            int ub = (int)tree[u].order_of_key({b + 1, INT_MIN});
            int lb = (int)tree[u].order_of_key({a, INT_MIN});
            return ub - lb;
        }
        int mid = (l + r) >> 1;
        return count(le(u), l, mid, L, R, a, b) + count(ri(u), mid + 1, r, L, R, a, b);
    }
    int count(int l, int r, int a, int b) { return count(1, 0, n - 1, l, r, a, b); }
    int less(int l, int r, int k) { return count(l, r, tree[1].begin()->first, k - 1); }
    void update(int u, int l, int r, int i, T x) {
        tree[u].erase({v[i], i});
        if (l == r) {
            v[i] = x;
        } else {
            int mid = (l + r) >> 1;
            if (i <= mid) update(le(u), l, mid, i, x);
            else update(ri(u), mid + 1, r, i, x);
        }
        tree[u].insert({v[i], i});
    }
    void update(int i, T x) { update(1, 0, n - 1, i, x); }
};
\end{lstlisting}
\hfill

\section{Operation Queue}


Fila que armazena o resultado do operatório dos itens (ou seja, dado uma fila, responde qual é o elemento mínimo, por exemplo). A fila possui a operação \texttt{get} que retorna o resultado do operatório dos itens da fila em $\mathcal{O}(1)$ amortizado. Chamar o método \texttt{get} em uma fila vazia é indefinido.



\textbf{Obs}: usa a estrutura Operation Stack (também descrita nesse Almanaque).

\hfill

Codigo: op\_queue.cpp

\begin{lstlisting}[language=C++]
template <typename T, auto OP>
struct op_queue {
    op_stack<T, OP> in, out;
    void push(T x) { in.push(x); }
    void pop() {
        if (out.empty()) {
            while (!in.empty()) {
                out.push(in.top());
                in.pop();
            }
        }
        out.pop();
    }
    T get() {
        if (out.empty()) return in.get();
        if (in.empty()) return out.get();
        return OP(in.get(), out.get());
    }
    T front() {
        if (out.empty()) return in.bottom();
        return out.top();
    }
    T back() {
        if (in.empty()) return out.bottom();
        return in.top();
    }
};
\end{lstlisting}
\hfill

\section{Operation Stack}


Pilha que armazena o resultado do operatório dos itens (ou seja, dado uma pilha, responde qual é o elemento mínimo, por exemplo). A pilha possui a operação \texttt{get} que retorna o resultado do operatório dos itens da pilha em $\mathcal{O}(1)$ amortizado. Chamar o método \texttt{get} em uma pilha vazia é indefinido.



A pilha é um template e recebe como argumentos o tipo dos itens e a função operatória. A função operatória deve receber dois argumentos do tipo dos itens e retornar um valor do mesmo tipo.



Exemplo de como passar a função operatória para a pilha:

    

\begin{lstlisting}[language=C++]
int f(int a, int b) { return a + b; }

void test() {
    auto g = [](int a, int b) { return a ^ b; };

    op_stack<int, f> st;
    op_stack<int, g> st2;

    st.push(1);
    st.push(1);
    st2.push(1);
    st2.push(1);
    cout << st.get() << endl; // 2
    cout << st2.get() << endl; // 0
}
\end{lstlisting}



Pode ser tanto função normal quanto lambda.
\hfill

Codigo: op\_stack.cpp

\begin{lstlisting}[language=C++]
template <typename T, auto OP>
struct op_stack {
    vector<pair<T, T>> st;
    T get() { return st.back().second; }
    T top() { return st.back().first; }
    T bottom() { return st.front().first; }
    void push(T x) {
        auto snd = st.empty() ? x : OP(st.back().second, x);
        st.push_back({x, snd});
    }
    void pop() { st.pop_back(); }
    bool empty() { return st.empty(); }
    int size() { return (int)st.size(); }
};\end{lstlisting}
\hfill

\section{Ordered Set}


Set com operações de busca por ordem e índice.



Pode ser usado como um \texttt{std::set} normal, a principal diferença são duas novas operações possíveis:



\begin{itemize}
\item \texttt{find\_by\_order(k)}: retorna um iterador para o $k$-ésimo menor elemento no set (indexado em 0).
\item \texttt{order\_of\_key(k)}: retorna o número de elementos menores que $k$. (ou seja, o índice de $k$ no set)
\end{itemize}



Ambas as operações são $\mathcal{O}(\log n)$.



Também é possível criar um \texttt{ordered\_map}, funciona como um \texttt{std::map}, mas com as operações de busca por ordem e índice. \texttt{find\_by\_order(k)} retorna um iterador para a $k$-ésima menor \textbf{key} no mapa (indexado em 0). \texttt{order\_of\_key(k)} retorna o número de \textbf{keys} no mapa menores que $k$. (ou seja, o índice de $k$ no map).



Para simular um \texttt{std::multiset}, há várias formas:



\begin{itemize}
\item Usar um \texttt{std::pair} como elemento do set, com o primeiro elemento sendo o valor e o segundo sendo um identificador único para cada elemento. Para saber o número de elementos menores que $k$ no multiset, basta usar \texttt{order\_of\_key({k, -INF})}.
\end{itemize}



\begin{itemize}
\item Usar um \texttt{ordered\_map} com a key sendo o valor e o value sendo o número de ocorrências do valor no multiset. Para saber o número de elementos menores que $k$ no multiset, basta usar \texttt{order\_of\_key(k)}.
\end{itemize}



\begin{itemize}
\item Criar o set trocando o parâmetro \texttt{less<T>} por \texttt{less\_equal<T>}. Isso faz com que o set aceite elementos repetidos, e \texttt{order\_of\_key(k)} retorna o número de elementos menores ou iguais a \texttt{k} no multiset. Porém esse método não é recomendado pois gera algumas inconsistências, como por exemplo: \texttt{upper\_bound} funciona como \texttt{lower\_bound} e vice-versa, \texttt{find} sempre retorna \texttt{end()} e \texttt{erase} por valor não funciona, só por iterador. Dá pra usar se souber o que está fazendo.
\end{itemize}



Exemplo de uso do \texttt{ordered\_set}:



\begin{lstlisting}[language=C++]
ordered_set<int> X;
X.insert(1);
X.insert(2);
X.insert(4);
X.insert(8);
X.insert(16);
cout << *X.find_by_order(1) << endl; // 2
cout << *X.find_by_order(2) << endl; // 4
cout << *X.find_by_order(4) << endl; // 16
cout << (end(X) == X.find_by_order(5)) << endl; // true
cout << X.order_of_key(-5) << endl;  // 0
cout << X.order_of_key(1) << endl;   // 0
cout << X.order_of_key(3) << endl;   // 2
cout << X.order_of_key(4) << endl;   // 2
cout << X.order_of_key(400) << endl; // 5
\end{lstlisting}



Exemplo de uso do \texttt{ordered\_map}:



\begin{lstlisting}[language=C++]
ordered_map<int, int> Y;
Y[1] = 10;
Y[2] = 20;
Y[4] = 40;
Y[8] = 80;
Y[16] = 160;
cout << Y.find_by_order(1)->first << endl; // 2
cout << Y.find_by_order(1)->second << endl; // 20
cout << Y.order_of_key(5) << endl; // 3
cout << Y.order_of_key(10) << endl; // 4
cout << Y.order_of_key(4) << endl; // 2
\end{lstlisting}

\hfill

Codigo: ordered\_set.cpp

\begin{lstlisting}[language=C++]
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace __gnu_pbds;

template <typename T>
using ordered_set =
    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

template <typename T, typename U>
using ordered_map = tree<T, U, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\end{lstlisting}
\hfill

\section{Segment Tree}
\subsection{Segment Tree}


Implementação padrão de Segment Tree, suporta operações de consulta em intervalo e update pontual. Está implementada para soma, mas pode ser facilmente modificada para outras operações. A construção é $\mathcal{O}(n)$ e as operações de consulta e update são $\mathcal{O}(\log n )$.



\textbf{Dica}: A Seg Tree usa $4 \cdot n$ de memória pois cada nodo $p$ tem seus filhos $2 \cdot p$ (filho esquerdo) e $2 \cdot p + 1$ (filho direito). Há uma forma de indexar os nodos que usa $2 \cdot n$ de memória. Dado um nodo $p$ que representa o intervalo $[l, r]$, seu filho esquerdo é $p+1$ (e representa o intervalo $[l, mid]$) e seu filho direito é $p+2 \cdot (mid-l+1)$ (e representa o intervalo $[mid+1, r]$), onde $mid = (l+r)/2$.
\hfill

Codigo: seg\_tree.cpp

\begin{lstlisting}[language=C++]
struct SegTree {
    ll merge(ll a, ll b) { return a + b; }
    const ll neutral = 0;

    int n;
    vector<ll> t;

    void build(int p, int l, int r, const vector<ll> &v) {
        if (l == r) {
            t[p] = v[l];
        } else {
            int mid = (l + r) / 2;
            build(p * 2, l, mid, v);
            build(p * 2 + 1, mid + 1, r, v);
            t[p] = merge(t[p * 2], t[p * 2 + 1]);
        }
    }

    void build(int _n) { // pra construir com tamanho, mas vazia
        n = _n;
        t.assign(n * 4, neutral);
    }

    void build(const vector<ll> &v) { // pra construir com vector
        n = int(v.size());
        t.assign(n * 4, neutral);
        build(1, 0, n - 1, v);
    }
    void build(ll *bg, ll *en) { // pra construir com array de C
        build(vector<ll>(bg, en));
    }

    ll query(int p, int l, int r, int L, int R) {
        if (l > R || r < L) return neutral;
        if (l >= L && r <= R) return t[p];
        int mid = (l + r) / 2;
        auto ql = query(p * 2, l, mid, L, R);
        auto qr = query(p * 2 + 1, mid + 1, r, L, R);
        return merge(ql, qr);
    }
    ll query(int l, int r) { return query(1, 0, n - 1, l, r); }

    void update(int p, int l, int r, int i, ll x) {
        if (l == r) {
            t[p] += x; // soma
            // t[p] = x; // substitui
        } else {
            int mid = (l + r) / 2;
            if (i <= mid) update(p * 2, l, mid, i, x);
            else update(p * 2 + 1, mid + 1, r, i, x);
            t[p] = merge(t[p * 2], t[p * 2 + 1]);
        }
    }
    void update(int i, ll x) { update(1, 0, n - 1, i, x); }
};
\end{lstlisting}
\hfill

\subsection{Segment Tree 2D}


Segment Tree em 2 dimensões, suporta operações de update pontual e consulta em intervalo. A construção é $\mathcal{O}(n \cdot m)$ e as operações de consulta e update são $\mathcal{O}(\log n \cdot \log m)$.
\hfill

Codigo: seg\_tree\_2d.cpp

\begin{lstlisting}[language=C++]
const int MAX = 2505;

int n, m, mat[MAX][MAX], tree[4 * MAX][4 * MAX];

int le(int x) { return 2 * x + 1; }
int ri(int x) { return 2 * x + 2; }

void build_y(int nx, int lx, int rx, int ny, int ly, int ry) {
    if (ly == ry) {
        if (lx == rx) tree[nx][ny] = mat[lx][ly];
        else tree[nx][ny] = tree[le(nx)][ny] + tree[ri(nx)][ny];
    } else {
        int my = (ly + ry) / 2;
        build_y(nx, lx, rx, le(ny), ly, my);
        build_y(nx, lx, rx, ri(ny), my + 1, ry);
        tree[nx][ny] = tree[nx][le(ny)] + tree[nx][ri(ny)];
    }
}
void build_x(int nx, int lx, int rx) {
    if (lx != rx) {
        int mx = (lx + rx) / 2;
        build_x(le(nx), lx, mx);
        build_x(ri(nx), mx + 1, rx);
    }
    build_y(nx, lx, rx, 0, 0, m - 1);
}
void build() { build_x(0, 0, n - 1); }

void update_y(int nx, int lx, int rx, int ny, int ly, int ry, int x, int y, int v) {
    if (ly == ry) {
        if (lx == rx) tree[nx][ny] = v;
        else tree[nx][ny] = tree[le(nx)][ny] + tree[ri(nx)][ny];
    } else {
        int my = (ly + ry) / 2;
        if (y <= my) update_y(nx, lx, rx, le(ny), ly, my, x, y, v);
        else update_y(nx, lx, rx, ri(ny), my + 1, ry, x, y, v);
        tree[nx][ny] = tree[nx][le(ny)] + tree[nx][ri(ny)];
    }
}
void update_x(int nx, int lx, int rx, int x, int y, int v) {
    if (lx != rx) {
        int mx = (lx + rx) / 2;
        if (x <= mx) update_x(le(nx), lx, mx, x, y, v);
        else update_x(ri(nx), mx + 1, rx, x, y, v);
    }
    update_y(nx, lx, rx, 0, 0, m - 1, x, y, v);
}
void update(int x, int y, int v) { update_x(0, 0, n - 1, x, y, v); }

int sum_y(int nx, int ny, int ly, int ry, int qly, int qry) {
    if (ry < qly || ly > qry) return 0;
    if (qly <= ly && ry <= qry) return tree[nx][ny];
    int my = (ly + ry) / 2;
    return sum_y(nx, le(ny), ly, my, qly, qry) + sum_y(nx, ri(ny), my + 1, ry, qly, qry);
}
int sum_x(int nx, int lx, int rx, int qlx, int qrx, int qly, int qry) {
    if (rx < qlx || lx > qrx) return 0;
    if (qlx <= lx && rx <= qrx) return sum_y(nx, 0, 0, m - 1, qly, qry);
    int mx = (lx + rx) / 2;
    return sum_x(le(nx), lx, mx, qlx, qrx, qly, qry) +
           sum_x(ri(nx), mx + 1, rx, qlx, qrx, qly, qry);
}
int sum(int lx, int rx, int ly, int ry) { return sum_x(0, 0, n - 1, lx, rx, ly, ry); }
\end{lstlisting}
\hfill

\subsection{Segment Tree Beats Max And Sum Update}


Segment Tree que suporta update de maximo, update de soma e query de soma. Utiliza uma fila de lazy para diferenciar os updates. A construção é $\mathcal{O}(n)$ e as operações de consulta e update são $\mathcal{O}(\log n)$.
\hfill

Codigo: seg\_tree\_beats\_max\_and\_sum\_update.cpp

\begin{lstlisting}[language=C++]
#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define INF 1e9
#define fi first
#define se second

typedef pair<int, int> ii;

struct Node {
    int m1 = INF, m2 = INF, cont = 0;
    ll soma = 0;
    queue<ii> lazy;

    void set(int v) {
        m1 = v;
        cont = 1;
        soma = v;
    }

    void merge(Node a, Node b) {
        m1 = min(a.m1, b.m1);
        m2 = INF;
        if (a.m1 != b.m1) m2 = min(m2, max(a.m1, b.m1));
        if (a.m2 != m1) m2 = min(m2, a.m2);
        if (b.m2 != m1) m2 = min(m2, b.m2);
        cont = (a.m1 == m1 ? a.cont : 0) + (b.m1 == m1 ? b.cont : 0);
        soma = a.soma + b.soma;
    }

    void print() { printf("%d %d %d %lld\n", m1, m2, cont, soma); }
};

int n, q;
vector<Node> tree;

int le(int n) { return 2 * n + 1; }
int ri(int n) { return 2 * n + 2; }

void push(int n, int esq, int dir) {
    while (!tree[n].lazy.empty()) {
        ii p = tree[n].lazy.front();
        tree[n].lazy.pop();
        int op = p.fi, v = p.se;
        if (op == 0) {
            if (v <= tree[n].m1) continue;
            tree[n].soma += (ll)abs(tree[n].m1 - v) * tree[n].cont;
            tree[n].m1 = v;
            if (esq != dir) {
                tree[le(n)].lazy.push({0, v});
                tree[ri(n)].lazy.push({0, v});
            }
        } else if (op == 1) {
            tree[n].soma += v * (dir - esq + 1);
            tree[n].m1 += v;
            tree[n].m2 += v;
            if (esq != dir) {
                tree[le(n)].lazy.push({1, v});
                tree[ri(n)].lazy.push({1, v});
            }
        }
    }
}

void build(int n, int esq, int dir, vector<int> &v) {
    if (esq == dir) {
        tree[n].set(v[esq]);
    } else {
        int mid = (esq + dir) / 2;
        build(le(n), esq, mid, v);
        build(ri(n), mid + 1, dir, v);
        tree[n].merge(tree[le(n)], tree[ri(n)]);
    }
}
void build(vector<int> &v) { build(0, 0, n - 1, v); }

// ai = max(ai, mi) em [l, r]
void update(int n, int esq, int dir, int l, int r, int mi) {
    push(n, esq, dir);
    if (esq > r || dir < l || mi <= tree[n].m1) return;
    if (l <= esq && dir <= r && mi < tree[n].m2) {
        tree[n].soma += (ll)abs(tree[n].m1 - mi) * tree[n].cont;
        tree[n].m1 = mi;
        if (esq != dir) {
            tree[le(n)].lazy.push({0, mi});
            tree[ri(n)].lazy.push({0, mi});
        }
    } else {
        int mid = (esq + dir) / 2;
        update(le(n), esq, mid, l, r, mi);
        update(ri(n), mid + 1, dir, l, r, mi);
        tree[n].merge(tree[le(n)], tree[ri(n)]);
    }
}
void update(int l, int r, int mi) { update(0, 0, n - 1, l, r, mi); }

// soma v em [l, r]
void upsoma(int n, int esq, int dir, int l, int r, int v) {
    push(n, esq, dir);
    if (esq > r || dir < l) return;
    if (l <= esq && dir <= r) {
        tree[n].soma += v * (dir - esq + 1);
        tree[n].m1 += v;
        tree[n].m2 += v;
        if (esq != dir) {
            tree[le(n)].lazy.push({1, v});
            tree[ri(n)].lazy.push({1, v});
        }
    } else {
        int mid = (esq + dir) / 2;
        upsoma(le(n), esq, mid, l, r, v);
        upsoma(ri(n), mid + 1, dir, l, r, v);
        tree[n].merge(tree[le(n)], tree[ri(n)]);
    }
}
void upsoma(int l, int r, int v) { upsoma(0, 0, n - 1, l, r, v); }

// soma de [l, r]
int query(int n, int esq, int dir, int l, int r) {
    push(n, esq, dir);
    if (esq > r || dir < l) return 0;
    if (l <= esq && dir <= r) return tree[n].soma;
    int mid = (esq + dir) / 2;
    return query(le(n), esq, mid, l, r) + query(ri(n), mid + 1, dir, l, r);
}
int query(int l, int r) { return query(0, 0, n - 1, l, r); }

int main() {
    cin >> n;
    tree.assign(4 * n, Node());
    build(v);
}
\end{lstlisting}
\hfill

\subsection{Segment Tree Beats Max Update}


Segment Tree que suporta update de maximo e query de soma. A construção é $\mathcal{O}(n)$ e as operações de consulta e update são $\mathcal{O}(\log n)$.

\hfill

Codigo: seg\_tree\_beats.cpp

\begin{lstlisting}[language=C++]
#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define INF 1e9

struct Node {
    int m1 = INF, m2 = INF, cont = 0, lazy = 0;
    ll soma = 0;

    void set(int v) {
        m1 = v;
        cont = 1;
        soma = v;
    }

    void merge(Node a, Node b) {
        m1 = min(a.m1, b.m1);
        m2 = INF;
        if (a.m1 != b.m1) m2 = min(m2, max(a.m1, b.m1));
        if (a.m2 != m1) m2 = min(m2, a.m2);
        if (b.m2 != m1) m2 = min(m2, b.m2);
        cont = (a.m1 == m1 ? a.cont : 0) + (b.m1 == m1 ? b.cont : 0);
        soma = a.soma + b.soma;
    }

    void print() { printf("%d %d %d %lld %d\n", m1, m2, cont, soma, lazy); }
};

int n, q;
vector<Node> tree;

int le(int n) { return 2 * n + 1; }
int ri(int n) { return 2 * n + 2; }

void push(int n, int esq, int dir) {
    if (tree[n].lazy <= tree[n].m1) return;
    tree[n].soma += (ll)abs(tree[n].m1 - tree[n].lazy) * tree[n].cont;
    tree[n].m1 = tree[n].lazy;
    if (esq != dir) {
        tree[le(n)].lazy = max(tree[le(n)].lazy, tree[n].lazy);
        tree[ri(n)].lazy = max(tree[ri(n)].lazy, tree[n].lazy);
    }
    tree[n].lazy = 0;
}

void build(int n, int esq, int dir, vector<int> &v) {
    if (esq == dir) {
        tree[n].set(v[esq]);
    } else {
        int mid = (esq + dir) / 2;
        build(le(n), esq, mid, v);
        build(ri(n), mid + 1, dir, v);
        tree[n].merge(tree[le(n)], tree[ri(n)]);
    }
}
void build(vector<int> &v) { build(0, 0, n - 1, v); }

// ai = max(ai, mi) em [l, r]
void update(int n, int esq, int dir, int l, int r, int mi) {
    push(n, esq, dir);
    if (esq > r || dir < l || mi <= tree[n].m1) return;
    if (l <= esq && dir <= r && mi < tree[n].m2) {
        tree[n].lazy = mi;
        push(n, esq, dir);
    } else {
        int mid = (esq + dir) / 2;
        update(le(n), esq, mid, l, r, mi);
        update(ri(n), mid + 1, dir, l, r, mi);
        tree[n].merge(tree[le(n)], tree[ri(n)]);
    }
}
void update(int l, int r, int mi) { update(0, 0, n - 1, l, r, mi); }

// soma de [l, r]
int query(int n, int esq, int dir, int l, int r) {
    push(n, esq, dir);
    if (esq > r || dir < l) return 0;
    if (l <= esq && dir <= r) return tree[n].soma;
    int mid = (esq + dir) / 2;
    return query(le(n), esq, mid, l, r) + query(ri(n), mid + 1, dir, l, r);
}
int query(int l, int r) { return query(0, 0, n - 1, l, r); }

int main() {
    cin >> n;
    tree.assign(4 * n, Node());
}
\end{lstlisting}
\hfill

\subsection{Segment Tree Esparsa}


Segment Tree Esparsa, ou seja, não armazena todos os nodos da árvore, apenas os necessários, dessa forma ela suporta operações em intervalos arbitrários. A construção é $\mathcal{O}(1)$ e as operações de consulta e update são $\mathcal{O}(\log L)$, onde $L$ é o tamanho do intervalo. A implementação suporta operações de consulta em intervalo e update pontual. Está implementada para soma, mas pode ser facilmente modificada para outras operações. 



Para usar, declarar \texttt{SegTree<L, R> st} para suportar updates e queries em posições de \texttt{L} a \texttt{R}. \texttt{L} e \texttt{R} podem inclusive ser negativos.



\textbf{Dica}: No construtor da Seg Tree, fazer \texttt{t.reserve(MAX); Lc.reserve(MAX); Rc.reserve(MAX);} pode ajudar bastante no runtime, pois aloca espaço para os vetores e evita muitas realocações durante a execução. Nesse caso, \texttt{MAX} é geralmente $\mathcal{O}(Q \cdot \log L)$, onde $Q$ é o número de queries e $L$ é o tamanho do intervalo.
\hfill

Codigo: seg\_tree\_sparse.cpp

\begin{lstlisting}[language=C++]
template <ll MINL = (ll)-1e9 - 5, ll MAXR = (ll)1e9 + 5>
struct SegTree {
    ll merge(ll a, ll b) { return a + b; }
    const ll neutral = 0;

    vector<ll> t;
    vector<int> Lc, Rc;

    inline int newnode() {
        t.push_back(neutral);
        Lc.push_back(-1);
        Rc.push_back(-1);
        return (int)t.size() - 1;
    }

    inline int le(int p) {
        if (Lc[p] == -1) Lc[p] = newnode();
        return Lc[p];
    }

    inline int ri(int p) {
        if (Rc[p] == -1) Rc[p] = newnode();
        return Rc[p];
    }

    SegTree() { newnode(); }

    ll query(int p, ll l, ll r, ll L, ll R) {
        if (l > R || r < L) return neutral;
        if (l >= L && r <= R) return t[p];
        ll mid = l + (r - l) / 2;
        auto ql = query(le(p), l, mid, L, R);
        auto qr = query(ri(p), mid + 1, r, L, R);
        return merge(ql, qr);
    }
    ll query(ll l, ll r) { return query(0, MINL, MAXR, l, r); }

    void update(int p, ll l, ll r, ll i, ll x) {
        if (l == r) {
            t[p] += x; // soma
            // t[p] = x; // substitui
            return;
        }
        ll mid = l + (r - l) / 2;
        if (i <= mid) update(le(p), l, mid, i, x);
        else update(ri(p), mid + 1, r, i, x);
        t[u] = merge(t[le(p)], t[ri(p)]);
    }
    void update(ll i, ll x) { update(0, MINL, MAXR, i, x); }
};\end{lstlisting}
\hfill

\subsection{Segment Tree Kadane}


Implementação de uma Segment Tree que suporta update pontual e query de soma máxima de um subarray em um intervalo. A construção é $\mathcal{O}(n)$ e as operações de consulta e update são $\mathcal{O}(\log n)$.



É uma Seg Tree normal, a magia está na função \texttt{merge} que é a função que computa a resposta do nodo atual. A ideia do \texttt{merge} da Seg Tree de Kadane de combinar respostas e informações já computadas dos filhos é muito útil e pode ser aplicada em muitos problemas.



\textbf{Obs}: não considera o subarray vazio como resposta.



\textbf{Dica}: A Seg Tree usa $4 \cdot n$ de memória pois cada nodo $p$ tem seus filhos $2 \cdot p$ (filho esquerdo) e $2 \cdot p + 1$ (filho direito). Há uma forma de indexar os nodos que usa $2 \cdot n$ de memória. Dado um nodo $p$ que representa o intervalo $[l, r]$, seu filho esquerdo é $p+1$ (e representa o intervalo $[l, mid]$) e seu filho direito é $p+2 \cdot (mid-l+1)$ (e representa o intervalo $[mid+1, r]$), onde $mid = (l+r)/2$.
\hfill

Codigo: seg\_tree\_kadane.cpp

\begin{lstlisting}[language=C++]
struct SegTree {
    struct node {
        ll sum, pref, suf, ans;
    };
    const node neutral = {0, 0, 0, 0};
    node merge(const node &a, const node &b) {
        return {
            a.sum + b.sum,
            max(a.pref, a.sum + b.pref),
            max(b.suf, b.sum + a.suf),
            max({a.ans, b.ans, a.suf + b.pref})
        };
    }

    int n;
    vector<node> t;

    void build(int p, int l, int r, const vector<ll> &v) {
        if (l == r) {
            t[p] = {v[l], v[l], v[l], v[l]};
        } else {
            int mid = (l + r) / 2;
            build(p * 2, l, mid, v);
            build(p * 2 + 1, mid + 1, r, v);
            t[p] = merge(t[p * 2], t[p * 2 + 1]);
        }
    }

    void build(int _n) { // pra construir com tamanho, mas vazia
        n = _n;
        t.assign(n * 4, neutral);
    }

    void build(const vector<ll> &v) { // pra construir com vector
        n = int(v.size());
        t.assign(n * 4, neutral);
        build(1, 0, n - 1, v);
    }
    void build(ll *bg, ll *en) { // pra construir com array de C
        build(vector<ll>(bg, en));
    }

    node query(int p, int l, int r, int L, int R) {
        if (l > R || r < L) return neutral;
        if (l >= L && r <= R) return t[p];
        int mid = (l + r) / 2;
        auto ql = query(p * 2, l, mid, L, R);
        auto qr = query(p * 2 + 1, mid + 1, r, L, R);
        return merge(ql, qr);
    }
    ll query(int l, int r) { return query(1, 0, n - 1, l, r).ans; }

    void update(int p, int l, int r, int i, ll x) {
        if (l == r) {
            t[p] = {x, x, x, x};
        } else {
            int mid = (l + r) / 2;
            if (i <= mid) update(p * 2, l, mid, i, x);
            else update(p * 2 + 1, mid + 1, r, i, x);
            t[p] = merge(t[p * 2], t[p * 2 + 1]);
        }
    }
    void update(int i, ll x) { update(1, 0, n - 1, i, x); }
};\end{lstlisting}
\hfill

\subsection{Segment Tree Lazy}


Lazy Propagation é uma técnica para updatar a Segment Tree que te permite fazer updates em intervalos, não necessariamente pontuais. Esta implementação responde consultas de soma em intervalo e updates de soma ou atribuição em intervalo, veja o método \texttt{update}.



A construção é $\mathcal{O}(n)$ e as operações de consulta e update são $\mathcal{O}(\log n)$.



\textbf{Dica}: A Seg Tree usa $4 \cdot n$ de memória pois cada nodo $p$ tem seus filhos $2 \cdot p$ (filho esquerdo) e $2 \cdot p + 1$ (filho direito). Há uma forma de indexar os nodos que usa $2 \cdot n$ de memória. Dado um nodo $p$ que representa o intervalo $[l, r]$, seu filho esquerdo é $p+1$ (e representa o intervalo $[l, mid]$) e seu filho direito é $p+2 \cdot (mid-l+1)$ (e representa o intervalo $[mid+1, r]$), onde $mid = (l+r)/2$.
\hfill

Codigo: seg\_tree\_lazy.cpp

\begin{lstlisting}[language=C++]
struct SegTree {
    ll merge(ll a, ll b) { return a + b; }
    const ll neutral = 0;

    int n;
    vector<ll> t, lazy;
    vector<bool> replace;

    void push(int p, int l, int r) {
        if (replace[p]) {
            t[p] = lazy[p] * (r - l + 1);
            if (l != r) {
                lazy[p * 2] = lazy[p];
                lazy[p * 2 + 1] = lazy[p];
                replace[p * 2] = replace[p];
                replace[p * 2 + 1] = replace[p];
            }
        } else if (lazy[p] != 0) {
            t[p] += lazy[p] * (r - l + 1);
            if (l != r) {
                lazy[p * 2] += lazy[p];
                lazy[p * 2 + 1] += lazy[p];
            }
        }
        replace[p] = false;
        lazy[p] = 0;
    }

    void build(int p, int l, int r, const vector<ll> &v) {
        if (l == r) {
            t[p] = v[l];
        } else {
            int mid = (l + r) / 2;
            build(p * 2, l, mid, v);
            build(p * 2 + 1, mid + 1, r, v);
            t[p] = merge(t[p * 2], t[p * 2 + 1]);
        }
    }

    void build(int _n) { // pra construir com tamanho, mas vazia
        n = _n;
        t.assign(n * 4, neutral);
        lazy.assign(n * 4, 0);
        replace.assign(n * 4, false);
    }

    void build(const vector<ll> &v) { // pra construir com vector
        n = (int)v.size();
        t.assign(n * 4, neutral);
        lazy.assign(n * 4, 0);
        replace.assign(n * 4, false);
        build(1, 0, n - 1, v);
    }
    void build(ll *bg, ll *en) { // pra construir com array de C
        build(vector<ll>(bg, en));
    }

    ll query(int p, int l, int r, int L, int R) {
        push(p, l, r);
        if (l > R || r < L) return neutral;
        if (l >= L && r <= R) return t[p];
        int mid = (l + r) / 2;
        auto ql = query(p * 2, l, mid, L, R);
        auto qr = query(p * 2 + 1, mid + 1, r, L, R);
        return merge(ql, qr);
    }
    ll query(int l, int r) { return query(1, 0, n - 1, l, r); }

    void update(int p, int l, int r, int L, int R, ll val, bool repl) {
        push(p, l, r);
        if (l > R || r < L) return;
        if (l >= L && r <= R) {
            lazy[p] = val;
            replace[p] = repl;
            push(p, l, r);
        } else {
            int mid = (l + r) / 2;
            update(p * 2, l, mid, L, R, val, repl);
            update(p * 2 + 1, mid + 1, r, L, R, val, repl);
            t[p] = merge(t[p * 2], t[p * 2 + 1]);
        }
    }
    void update(int l, int r, ll val, bool repl = false) {
        update(1, 0, n - 1, l, r, val, repl);
    }
};\end{lstlisting}
\hfill

\subsection{Segment Tree Lazy Esparsa}


Segment Tree com Lazy Propagation e Esparsa. Está implementada com update de soma em range e atribuição em range, e query de soma em range. Construção em $\mathcal{O}(1)$ e operações de update e query em $\mathcal{O}(\log L)$, onde $L$ é o tamanho do intervalo.



\textbf{Dica}: No construtor da Seg Tree, fazer \texttt{t.reserve(MAX); lazy.reserve(MAX); replace.reserve(MAX); Lc.reserve(MAX); Rc.reserve(MAX);} pode ajudar bastante no runtime, pois aloca espaço para os vetores e evita muitas realocações durante a execução. Nesse caso, \texttt{MAX} é geralmente $\mathcal{O}(Q \cdot \log L)$, onde $Q$ é o número de queries e $L$ é o tamanho do intervalo.
\hfill

Codigo: seg\_tree\_sparse\_lazy.cpp

\begin{lstlisting}[language=C++]
template <ll MINL = (ll)-1e9 - 5, ll MAXR = (ll)1e9 + 5>
struct SegTree {
    ll merge(ll a, ll b) { return a + b; }
    const ll neutral = 0;

    vector<ll> t, lazy;
    vector<int> Lc, Rc;
    vector<bool> replace;

    inline int newnode() {
        t.push_back(neutral);
        Lc.push_back(-1);
        Rc.push_back(-1);
        lazy.push_back(0);
        replace.push_back(false);
        return (int)t.size() - 1;
    }

    inline int le(int p) {
        if (Lc[p] == -1) Lc[p] = newnode();
        return Lc[p];
    }

    inline int ri(int p) {
        if (Rc[p] == -1) Rc[p] = newnode();
        return Rc[p];
    }

    SegTree() { newnode(); }

    void push(int p, ll l, ll r) {
        if (replace[p]) {
            t[p] = lazy[p] * (r - l + 1);
            if (l != r) {
                lazy[le(p)] = lazy[p];
                lazy[ri(p)] = lazy[p];
                replace[le(p)] = replace[p];
                replace[ri(p)] = replace[p];
            }
        } else if (lazy[p] != 0) {
            t[p] += lazy[p] * (r - l + 1);
            if (l != r) {
                lazy[le(p)] += lazy[p];
                lazy[ri(p)] += lazy[p];
            }
        }
        replace[p] = false;
        lazy[p] = 0;
    }

    ll query(int p, ll l, ll r, ll L, ll R) {
        push(p, l, r);
        if (l > R || r < L) return neutral;
        if (l >= L && r <= R) return t[p];
        ll mid = l + (r - l) / 2;
        auto ql = query(le(p), l, mid, L, R);
        auto qr = query(ri(p), mid + 1, r, L, R);
        return merge(ql, qr);
    }
    ll query(ll l, ll r) { return query(0, MINL, MAXR, l, r); }

    void update(int p, ll l, ll r, ll L, ll R, ll val, bool repl) {
        push(p, l, r);
        if (l > R || r < L) return;
        if (l >= L && r <= R) {
            lazy[p] = val;
            replace[p] = repl;
            push(p, l, r);
        } else {
            ll mid = l + (r - l) / 2;
            update(le(p), l, mid, L, R, val, repl);
            update(ri(p), mid + 1, r, L, R, val, repl);
            t[p] = merge(t[le(p)], t[ri(p)]);
        }
    }
    void update(ll l, ll r, ll val, bool repl = false) {
        update(0, MINL, MAXR, l, r, val, repl);
    }
};\end{lstlisting}
\hfill

\subsection{Segment Tree Persisente}


Uma Seg Tree Esparsa, só que com persistência, ou seja, pode voltar para qualquer estado anterior da árvore, antes de qualquer modificação.



Os métodos \texttt{query} e \texttt{update} agora recebem um parâmetro a mais, que é a root (versão da árvore) que se deja modificar. Todos os métodos continuam $\mathcal{O}(\log n)$.



O vetor \texttt{roots} guarda na posição \texttt{i} a root da árvore após o \texttt{i}-ésimo update.



\textbf{Dica}: No construtor da Seg Tree, fazer \texttt{t.reserve(MAX); Lc.reserve(MAX); Rc.reserve(MAX); roots.reserve(Q);} pode ajudar bastante no runtime, pois aloca espaço para os vetores e evita muitas realocações durante a execução. Nesse caso, \texttt{MAX} é geralmente $\mathcal{O}(Q \cdot \log L)$, onde $Q$ é o número de queries e $L$ é o tamanho do intervalo.
\hfill

Codigo: seg\_tree\_persistent.cpp

\begin{lstlisting}[language=C++]
template <ll MINL = (ll)-1e9 - 5, ll MAXR = (ll)1e9 + 5>
struct SegTree {
    ll merge(ll a, ll b) { return a + b; }
    const ll neutral = 0;

    vector<ll> t;
    vector<int> Lc, Rc, roots;

    inline int newnode() {
        t.push_back(neutral);
        Lc.push_back(-1);
        Rc.push_back(-1);
        return (int)t.size() - 1;
    }

    inline int le(int p) {
        if (Lc[p] == -1) Lc[p] = newnode();
        return Lc[p];
    }

    inline int ri(int p) {
        if (Rc[p] == -1) Rc[p] = newnode();
        return Rc[p];
    }

    SegTree() { roots.push_back(newnode()); }

    ll query(int p, ll l, ll r, ll L, ll R) {
        if (l > R || r < L) return neutral;
        if (l >= L && r <= R) return t[p];
        ll mid = l + (r - l) / 2;
        auto ql = query(le(p), l, mid, L, R);
        auto qr = query(ri(p), mid + 1, r, L, R);
        return merge(ql, qr);
    }
    ll query(ll l, ll r, int root = -1) {
        if (root == -1) root = roots.back();
        debug(root, MINL, MAXR, l, r);
        return query(root, MINL, MAXR, l, r);
    }

    void update(int p, int old, ll l, ll r, ll i, ll x) {
        if (l == r) {
            t[p] = x; // substitui
            // t[p] += x; // soma
            return;
        }
        ll mid = l + (r - l) / 2;
        if (i <= mid) {
            Rc[p] = ri(old);
            update(le(p), le(old), l, mid, i, x);
        } else {
            Lc[p] = le(old);
            update(ri(p), ri(old), mid + 1, r, i, x);
        }
        t[p] = merge(t[le(p)], t[ri(p)]);
    }
    int update(ll i, ll x, int root = -1) {
        int new_root = newnode();
        if (root == -1) root = roots.back();
        update(new_root, root, MINL, MAXR, i, x);
        roots.push_back(new_root);
        return roots.back();
    }
    int copy_root(int root) {
        int new_root = newnode();
        Lc[new_root] = le(root);
        Rc[new_root] = ri(root);
        roots.push_back(new_root);
        return roots.back();
    }
};\end{lstlisting}
\hfill

\section{Sparse Table}
\subsection{Disjoint Sparse Table}


Uma Sparse Table melhorada, construção ainda em $\mathcal{O}(n \log n)$, mas agora suporta queries de \textbf{qualquer} operação associativa em $\mathcal{O}(1)$, não precisando mais ser idempotente.

\hfill

Codigo: dst.cpp

\begin{lstlisting}[language=C++]
struct DisjointSparseTable {
    int n, LG;
    vector<vector<ll>> st;
    ll merge(ll a, ll b) { return a + b; }
    const ll neutral = 0;
    void build(const vector<ll> &v) {
        int sz = (int)v.size();
        n = 1, LG = 1;
        while (n < sz) n <<= 1, LG++;
        st = vector<vector<ll>>(LG, vector<ll>(n));
        for (int i = 0; i < n; i++) st[0][i] = i < sz ? v[i] : neutral;
        for (int i = 1; i < LG - 1; i++) {
            for (int j = (1 << i); j < n; j += (1 << (i + 1))) {
                st[i][j] = st[0][j];
                st[i][j - 1] = st[0][j - 1];
                for (int k = 1; k < (1 << i); k++) {
                    st[i][j + k] = merge(st[i][j + k - 1], st[0][j + k]);
                    st[i][j - 1 - k] = merge(st[0][j - k - 1], st[i][j - k]);
                }
            }
        }
    }
    void build(ll *bg, ll *en) { build(vector<ll>(bg, en)); }
    ll query(int l, int r) {
        if (l == r) return st[0][l];
        int i = 31 - __builtin_clz(l ^ r);
        return merge(st[i][l], st[i][r]);
    }
} dst;\end{lstlisting}
\hfill

\subsection{Sparse Table}


Precomputa em $\mathcal{O}(n \log n)$ uma tabela que permite responder consultas de mínimo/máximo em intervalos em $\mathcal{O}(1)$.



A implementação atual é para mínimo, mas pode ser facilmente modificada para máximo ou outras operações.



A restrição é de que a operação deve ser associativa e idempotente (ou seja, $f(x, x) = x$).



Exemplos de operações idempotentes: \texttt{min}, \texttt{max}, \texttt{gcd}, \texttt{lcm}.



Exemplos de operações não idempotentes: \texttt{soma}, \texttt{xor}, \texttt{produto}.



\textbf{Obs}: não suporta updates.

\hfill

Codigo: sparse\_table.cpp

\begin{lstlisting}[language=C++]
struct SparseTable {
    int n, LG;
    vector<vector<ll>> st;
    ll merge(ll a, ll b) { return min(a, b); }
    const ll neutral = 1e18;
    void build(const vector<ll> &v) {
        n = (int)v.size();
        LG = 32 - __builtin_clz(n);
        st = vector<vector<ll>>(LG, vector<ll>(n));
        for (int i = 0; i < n; i++) st[0][i] = v[i];
        for (int i = 0; i < LG - 1; i++)
            for (int j = 0; j + (1 << i) < n; j++)
                st[i + 1][j] = merge(st[i][j], st[i][j + (1 << i)]);
    }
    void build(ll *bg, ll *en) { build(vector<ll>(bg, en)); }
    ll query(int l, int r) {
        if (l > r) return neutral;
        int i = 31 - __builtin_clz(r - l + 1);
        return merge(st[i][l], st[i][r - (1 << i) + 1]);
    }
};
\end{lstlisting}
\hfill

\section{XOR Trie}


Uma Trie que armazena os números em binario (do bit mais significativo para o menos). Permite realizar inserção de um número $X$ em $\mathcal{O}(\log X)$. O inteiro \texttt{bits} no template da estrutura é a quantidade bits dos números você deseja considerar.



O método \texttt{max\_xor(X)} retorna o resultado do maior XOR de $X$ com algum número contido na Trie e \texttt{min\_xor(X)} resultado do menor XOR de $X$ com algum número contido na Trie. Note que o valor $X$ não precisa estar na Trie. Ambos os métodos são $\mathcal{O}(\log X)$.

\hfill

Codigo: xor\_trie.cpp

\begin{lstlisting}[language=C++]
struct XorTrie {
    const int bits = 30;
    vector<vector<int>> go;
    int root = 0, cnt = 1;
    void build(int n) { go.assign((n + 1) * bits, vector<int>(2, -1)); }
    void insert(int x) {
        int v = root;
        for (int i = bits - 1; i >= 0; i--) {
            int b = x >> i & 1;
            if (go[v][b] == -1) go[v][b] = cnt++;
            v = go[v][b];
        }
    }
    int max_xor(int x) {
        int v = root;
        int ans = 0;
        if (cnt <= 1) return -1;
        for (int i = bits - 1; i >= 0; i--) {
            int b = x >> i & 1;
            int good = go[v][!b];
            int bad = go[v][b];
            if (good != -1) {
                v = good;
                ans |= 1 << i;
            } else v = bad;
        }
        return ans;
    }
    int min_xor(int x) {
        int flipped = x ^ ((1 << bits) - 1);
        int query = max_xor(flipped);
        if (query == -1) return -1;
        return x ^ flipped ^ query;
    }
} trie;
\end{lstlisting}
\hfill

\newpage

%%%%%%
%
%
% Grafos
%
%
%%%%%%

\chapter{Grafos}

\section{2 SAT}


Algoritmo que resolve problema do 2-SAT. No 2-SAT, temos um conjunto de variáveis booleanas e cláusulas lógicas, onde cada cláusula é composta por duas variáveis. O problema é determinar se existe uma configuração das variáveis que satisfaça todas as cláusulas. O problema se transforma em um problema de encontrar as componentes fortemente conexas de um grafo direcionado, que resolvemos em $\mathcal{O}(N + M)$ com o algoritmo de Kosaraju. Onde $N$ é o número de variáveis e $M$ é o número de cláusulas.  



A configuração da solução fica guardada no vetor \texttt{assignment}.



Em relação ao sinal, tanto faz se 0 liga ou desliga, apenas siga o mesmo padrão.

\hfill

Codigo: 2\_sat.cpp

\begin{lstlisting}[language=C++]
struct sat2 {
    int n;
    vector<vector<int>> g, rg;
    vector<bool> vis, assignment;
    vector<int> topo, comp;

    sat2(int _n) {
        n = (2 * _n) + 2;
        // a true = 2 * a
        // a false = 2 * a + 1
        g.assign(n, vector<int>());
        rg.assign(n, vector<int>());
    }

    int get(int u) {
        if (u < 0) return 2 * (~u) + 1;
        else return 2 * u;
    }

    void add_impl(int u, int v) {
        u = get(u), v = get(v);
        g[u].push_back(v);
        rg[v].push_back(u);
        g[v ^ 1].push_back(u ^ 1);
        rg[u ^ 1].push_back(v ^ 1);
    }

    void add_or(int u, int v) { add_impl(~u, v); }

    void add_and(int u, int v) {
        add_or(u, u);
        add_or(v, v);
    }

    void add_xor(int u, int v) {
        add_impl(u, ~v);
        add_impl(~u, v);
    }

    void add_equals(int u, int v) {
        add_impl(u, v);
        add_impl(~u, ~v);
    }

    void toposort(int u) {
        vis[u] = true;
        for (int v : g[u])
            if (!vis[v]) toposort(v);
        topo.push_back(u);
    }

    void dfs(int u, int cc) {
        comp[u] = cc;
        for (int v : rg[u])
            if (comp[v] == -1) dfs(v, cc);
    }

    pair<bool, vector<bool>> solve() {
        topo.clear();
        vis.assign(n, false);

        for (int i = 0; i < n; i++)
            if (!vis[i]) toposort(i);
        reverse(topo.begin(), topo.end());

        comp.assign(n, -1);
        int cc = 0;
        for (auto u : topo)
            if (comp[u] == -1) dfs(u, cc++);

        assignment.assign(n / 2, false);
        for (int i = 0; i < n; i += 2) {
            if (comp[i] == comp[i + 1]) return {false, {}};
            assignment[i / 2] = comp[i] > comp[i + 1];
        }

        return {true, assignment};
    }
};\end{lstlisting}
\hfill

\section{Binary Lifting}
\subsection{Binary Lifting LCA}


Usa uma matriz para precomputar os ancestrais de um nodo, em que \texttt{up[u][i]} é o $2 ^ i$-ésimo ancestral de \texttt{u}. A construção é $\mathcal{O}(n \log n)$, e é possível consultar pelo $k$-ésimo ancestral de um nodo e pelo \textbf{LCA} de dois nodos em $\mathcal{O}(\log n)$.



\textbf{LCA}: Lowest Common Ancestor, o LCA de dois nodos $u$ e $v$ é o nodo mais profundo que é ancestral de ambos.

\hfill

Codigo: binary\_lifting\_lca.cpp

\begin{lstlisting}[language=C++]
const int N = 3e5 + 5, LG = 20;
vector<int> adj[N];

namespace bl {
    int t, up[N][LG], tin[N], tout[N];

    void dfs(int u, int p = -1) {
        tin[u] = t++;
        for (int i = 0; i < LG - 1; i++) up[u][i + 1] = up[up[u][i]][i];
        for (int v : adj[u])
            if (v != p) {
                up[v][0] = u;
                dfs(v, u);
            }
        tout[u] = t++;
    }

    void build(int root) {
        t = 1;
        up[root][0] = root;
        dfs(root);
    }

    bool ancestor(int u, int v) { return tin[u] <= tin[v] && tout[u] >= tout[v]; }

    int lca(int u, int v) {
        if (ancestor(u, v)) return u;
        if (ancestor(v, u)) return v;
        for (int i = LG - 1; i >= 0; i--)
            if (!ancestor(up[u][i], v)) u = up[u][i];
        return up[u][0];
    }

    int kth(int u, int k) {
        for (int i = 0; i < LG; i++)
            if (k & (1 << i)) u = up[u][i];
        return u;
    }

}
\end{lstlisting}
\hfill

\subsection{Binary Lifting Query}


Binary Lifting em que, além de queries de ancestrais, podemos fazer queries em caminhos. Seja $f(u, v)$ uma função que retorna algo sobre o caminho entre $u$ e $v$, como a soma dos valores dos nodos ou máximo valor do caminho, \texttt{st[u][i]} é o valor de $f(par[u], up[u][i])$, em que \texttt{up[u][i]} é o $2 ^ i$-ésimo ancestral de \texttt{u} e \texttt{par[u]} é o pai de \texttt{u}. A função $f$ deve ser associativa e comutativa.



A construção é $\mathcal{O}(n \log n)$, e é possível consultar em $\mathcal{O}(\log n)$ pelo valor de $f(u, v)$, em que $u$ e $v$ são nodos do grafo, através do método \texttt{query}. Também computa LCA e $k$-ésimo ancestral em $\mathcal{O}(\log n)$.



\textbf{Obs}: os valores precisam estar nos \textbf{nodos} e não nas arestas, para valores nas arestas verificar o \texttt{Binary Lifting Query Aresta}.
\hfill

Codigo: binary\_lifting\_query\_nodo.cpp

\begin{lstlisting}[language=C++]
const int N = 3e5 + 5, LG = 20;
vector<int> adj[N];

namespace bl {
    int t, up[N][LG], st[N][LG], tin[N], tout[N], val[N];

    const int neutral = 0;
    int merge(int l, int r) { return l + r; }

    void dfs(int u, int p = -1) {
        tin[u] = t++;
        for (int i = 0; i < LG - 1; i++) {
            up[u][i + 1] = up[up[u][i]][i];
            st[u][i + 1] = merge(st[u][i], st[up[u][i]][i]);
        }
        for (int v : adj[u])
            if (v != p) {
                up[v][0] = u, st[v][0] = val[u];
                dfs(v, u);
            }
        tout[u] = t++;
    }

    void build(int root) {
        t = 1;
        up[root][0] = root;
        st[root][0] = neutral;
        dfs(root);
    }

    bool ancestor(int u, int v) { return tin[u] <= tin[v] && tout[u] >= tout[v]; }

    int query2(int u, int v, bool include_lca) {
        if (ancestor(u, v)) return include_lca ? val[u] : neutral;
        int ans = val[u];
        for (int i = LG - 1; i >= 0; i--) {
            if (!ancestor(up[u][i], v)) {
                ans = merge(ans, st[u][i]);
                u = up[u][i];
            }
        }
        return include_lca ? merge(ans, st[u][0]) : ans;
    }

    int query(int u, int v) {
        if (u == v) return val[u];
        return merge(query2(u, v, 1), query2(v, u, 0));
    }

    int lca(int u, int v) {
        if (ancestor(u, v)) return u;
        if (ancestor(v, u)) return v;
        for (int i = LG - 1; i >= 0; i--)
            if (!ancestor(up[u][i], v)) u = up[u][i];
        return up[u][0];
    }

    int kth(int u, int k) {
        for (int i = 0; i < LG; i++)
            if (k & (1 << i)) u = up[u][i];
        return u;
    }

}
\end{lstlisting}
\hfill

\subsection{Binary Lifting Query 2}


Basicamente o mesmo que o anterior, mas esse resolve queries em que o \texttt{merge} não é necessariamente \textbf{comutativo}. Para fins de exemplo, o código está implementado para resolver queries de Kadane (máximo subarray sum) em caminhos.



Foi usado para passar esse problema:

https://codeforces.com/contest/1843/problem/F2
\hfill

Codigo: binary\_lifting\_query\_nodo2.cpp

\begin{lstlisting}[language=C++]
struct node {
    int pref, suff, sum, best;
    node() : pref(0), suff(0), sum(0), best(0) { }
    node(int x) : pref(x), suff(x), sum(x), best(x) { }
    node(int a, int b, int c, int d) : pref(a), suff(b), sum(c), best(d) { }
};

node merge(node l, node r) {
    int pref = max(l.pref, l.sum + r.pref);
    int suff = max(r.suff, r.sum + l.suff);
    int sum = l.sum + r.sum;
    int best = max(l.suff + r.pref, max(l.best, r.best));
    return node(pref, suff, sum, best);
}

struct BinaryLifting {
    vector<vector<int>> adj, up;
    vector<int> val, tin, tout;
    vector<vector<node>> st, st2;
    int N, LG, t;

    void build(int u, int p = -1) {
        tin[u] = t++;
        for (int i = 0; i < LG - 1; i++) {
            up[u][i + 1] = up[up[u][i]][i];
            st[u][i + 1] = merge(st[u][i], st[up[u][i]][i]);
            st2[u][i + 1] = merge(st2[up[u][i]][i], st2[u][i]);
        }
        for (int v : adj[u])
            if (v != p) {
                up[v][0] = u;
                st[v][0] = node(val[u]);
                st2[v][0] = node(val[u]);
                build(v, u);
            }
        tout[u] = t++;
    }

    void build(int root, vector<vector<int>> adj2, vector<int> v) {
        t = 1;
        N = (int)adj2.size();
        LG = 32 - __builtin_clz(N);
        adj = adj2;
        val = v;
        tin = tout = vector<int>(N);
        up = vector(N, vector<int>(LG));
        st = st2 = vector(N, vector<node>(LG));
        up[root][0] = root;
        st[root][0] = node(val[root]);
        st2[root][0] = node(val[root]);
        build(root);
    }

    bool ancestor(int u, int v) { return tin[u] <= tin[v] && tout[u] >= tout[v]; }

    node query2(int u, int v, bool include_lca, bool invert) {
        if (ancestor(u, v)) return include_lca ? node(val[u]) : node();
        node ans = node(val[u]);
        for (int i = LG - 1; i >= 0; i--) {
            if (!ancestor(up[u][i], v)) {
                if (invert) ans = merge(st2[u][i], ans);
                else ans = merge(ans, st[u][i]);
                u = up[u][i];
            }
        }
        return include_lca ? merge(ans, st[u][0]) : ans;
    }

    node query(int u, int v) {
        if (u == v) return node(val[u]);
        node l = query2(u, v, 1, 0);
        node r = query2(v, u, 0, 1);
        return merge(l, r);
    }

    int lca(int u, int v) {
        if (ancestor(u, v)) return u;
        if (ancestor(v, u)) return v;
        for (int i = LG - 1; i >= 0; i--)
            if (!ancestor(up[u][i], v)) u = up[u][i];
        return up[u][0];
    }

} bl, bl2;
\end{lstlisting}
\hfill

\subsection{Binary Lifting Query Aresta}


O mesmo Binary Lifting de query em nodos, porém agora com os valores nas arestas. As complexidades são as mesmas.

\hfill

Codigo: binary\_lifting\_query\_aresta.cpp

\begin{lstlisting}[language=C++]
const int N = 3e5 + 5, LG = 20;
vector<pair<int, int>> adj[N];

namespace bl {
    int t, up[N][LG], st[N][LG], tin[N], tout[N], val[N];

    const int neutral = 0;
    int merge(int l, int r) { return l + r; }

    void dfs(int u, int p = -1) {
        tin[u] = t++;
        for (int i = 0; i < LG - 1; i++) {
            up[u][i + 1] = up[up[u][i]][i];
            st[u][i + 1] = merge(st[u][i], st[up[u][i]][i]);
        }
        for (auto [w, v] : adj[u])
            if (v != p) {
                up[v][0] = u, st[v][0] = w;
                dfs(v, u);
            }
        tout[u] = t++;
    }

    void build(int root) {
        t = 1;
        up[root][0] = root;
        st[root][0] = neutral;
        dfs(root);
    }

    bool ancestor(int u, int v) { return tin[u] <= tin[v] && tout[u] >= tout[v]; }

    int query2(int u, int v) {
        if (ancestor(u, v)) return neutral;
        int ans = neutral;
        for (int i = LG - 1; i >= 0; i--) {
            if (!ancestor(up[u][i], v)) {
                ans = merge(ans, st[u][i]);
                u = up[u][i];
            }
        }
        return merge(ans, st[u][0]);
    }

    int query(int u, int v) {
        if (u == v) {
            return neutral;
#warning TRATAR ESSE CASO ACIMA
        }
        return merge(query2(u, v), query2(v, u));
    }

    int lca(int u, int v) {
        if (ancestor(u, v)) return u;
        if (ancestor(v, u)) return v;
        for (int i = LG - 1; i >= 0; i--)
            if (!ancestor(up[u][i], v)) u = up[u][i];
        return up[u][0];
    }

    int kth(int u, int k) {
        for (int i = 0; i < LG; i++)
            if (k & (1 << i)) u = up[u][i];
        return u;
    }
}
\end{lstlisting}
\hfill

\section{Centro e Diametro}


Algoritmo que encontra o centro e o diâmetro de um grafo em $\mathcal{O}(N + M)$ com duas BFS.



\textbf{Definição}: O centro de um grafo é igual ao subconjunto de nodos com excentricidade mínima. A excentricidade de um nodo é a maior distância dele para qualquer outro nodo. Em outras palavras, pra um nodo ser centro do grafo, ele deve minimizar a maior distância para qualquer outro nodo.



O diâmetro de um grafo é a maior distância entre dois nodos quaisquer.
\hfill

Codigo: graph\_center.cpp

\begin{lstlisting}[language=C++]
const int INF = 1e9 + 9;

vector<vector<int>> adj;

struct GraphCenter {
    int n, diam = 0;
    vector<int> centros, dist, pai;
    int bfs(int s) {
        queue<int> q;
        q.push(s);
        dist.assign(n + 5, INF);
        pai.assign(n + 5, -1);
        dist[s] = 0;
        int maxidist = 0, maxinode = 0;
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            if (dist[u] >= maxidist) maxidist = dist[u], maxinode = u;
            for (int v : adj[u]) {
                if (dist[u] + 1 < dist[v]) {
                    dist[v] = dist[u] + 1;
                    pai[v] = u;
                    q.push(v);
                }
            }
        }
        diam = max(diam, maxidist);
        return maxinode;
    }
    GraphCenter(int st = 0) : n(adj.size()) {
        int d1 = bfs(st);
        int d2 = bfs(d1);
        vector<int> path;
        for (int u = d2; u != -1; u = pai[u]) path.push_back(u);
        int len = path.size();
        if (len % 2 == 1) {
            centros.push_back(path[len / 2]);
        } else {
            centros.push_back(path[len / 2]);
            centros.push_back(path[len / 2 - 1]);
        }
    }
};
\end{lstlisting}
\hfill

\section{Centroids}
\subsection{Centroid}


Algoritmo que encontra os dois centróides de uma árvore em $\mathcal{O}(N)$.



\textbf{Definição}: O centróide de uma árvore é o nodo tal que, ao ser removido, divide a árvore em subárvores com no máximo metade dos nodos da árvore original. Em outras palavras, se a árvore tem tamanho $N$, todas as subárvores geradas pela remoção do centróide têm tamanho no máximo $\frac{N}{2}$. Uma árvore pode ter até dois centróides.
\hfill

Codigo: find\_centroid.cpp

\begin{lstlisting}[language=C++]
const int N = 3e5 + 5;

int sz[N];
vector<int> adj[N];

void dfs_sz(int u, int p) {
    sz[u] = 1;
    for (int v : adj[u]) {
        if (v != p) {
            dfs_sz(v, u);
            sz[u] += sz[v];
        }
    }
}

int centroid(int u, int p, int n) {
    for (int v : adj[u])
        if (v != p && sz[v] > n / 2) return centroid(v, u, n);
    return u;
}

pair<int, int> centroids(int u) {
    dfs_sz(u, u);
    int c = centroid(u, u, sz[u]);
    int c2 = -1;
    for (int v : adj[c])
        if (sz[u] == sz[v] * 2) c2 = v;
    return {c, c2};
}\end{lstlisting}
\hfill

\subsection{Centroid Decomposition}


Algoritmo que constrói a decomposição por centróides de uma árvore em $\mathcal{O}(N \log N)$.



Basicamente, a decomposição consiste em, repetidamente:



\begin{itemize}
\item Encontrar o centróide da árvore atual.
\item Remover o centróide e decompor as subárvores restantes.
\end{itemize}



A decomposição vai gerar uma nova árvore (chamada comumente de "Centroid Tree") onde cada nodo é um centróide da árvore original e as arestas representam a relação de pai-filho entre os centróides. A árvore tem altura $\log N$.



No código, \texttt{dis[u][j]} é a distância entre o nodo $u$ e seu $j$-ésimo ancestral na Centroid Tree.

\hfill

Codigo: centroid\_decomposition.cpp

\begin{lstlisting}[language=C++]
const int N = 3e5 + 5;

int sz[N], par[N];
bool rem[N];
vector<int> dis[N];
vector<int> adj[N];

int dfs_sz(int u, int p) {
    sz[u] = 1;
    for (int v : adj[u])
        if (v != p && !rem[v]) sz[u] += dfs_sz(v, u);
    return sz[u];
}

int centroid(int u, int p, int szn) {
    for (int v : adj[u])
        if (v != p && !rem[v] && sz[v] > szn / 2) return centroid(v, u, szn);
    return u;
}

void dfs_dis(int u, int p, int d = 0) {
    dis[u].push_back(d);
    for (int v : adj[u])
        if (v != p && !rem[v]) dfs_dis(v, u, d + 1);
}

void decomp(int u, int p) {
    int c = centroid(u, u, dfs_sz(u, u));

    rem[c] = true;
    par[c] = p;

    dfs_dis(c, c);

    // Faz algo na subárvore de c

    for (int v : adj[c])
        if (!rem[v]) decomp(v, c);
}

void build(int n) {
    for (int i = 0; i < n; i++) {
        rem[i] = false;
        dis[i].clear();
    }
    decomp(0, -1);
    for (int i = 0; i < n; i++) reverse(dis[i].begin(), dis[i].end());
}\end{lstlisting}
\hfill

\section{Fluxo}


Conjunto de algoritmos para calcular o fluxo máximo em redes de fluxo.



\textbf{} 


Muito útil para grafos bipartidos e para grafos com muitas arestas



Complexidade de tempo: $\mathcal{O}(V² * E)$, mas em grafo bipartido a complexidade é $\mathcal{O}(sqrt(V) * E)$



\textbf{} 


Útil para grafos com poucas arestas



Complexidade de tempo: $\mathcal{O}(V * E²)$



\textbf{} 


Computa o fluxo máximo com custo mínimo



Complexidade de tempo: $\mathcal{O}(V² * E²)$

\hfill

Codigo: EdmondsKarp.cpp

\begin{lstlisting}[language=C++]
const long long INF = 1e18;

struct FlowEdge {
    int u, v;
    long long cap, flow = 0;
    FlowEdge(int u, int v, long long cap) : u(u), v(v), cap(cap) { }
};

struct EdmondsKarp {
    int n, s, t, m = 0, vistoken = 0;
    vector<FlowEdge> edges;
    vector<vector<int>> adj;
    vector<int> visto;

    EdmondsKarp(int n, int s, int t) : n(n), s(s), t(t) {
        adj.resize(n);
        visto.resize(n);
    }

    void add_edge(int u, int v, long long cap) {
        edges.emplace_back(u, v, cap);
        edges.emplace_back(v, u, 0);
        adj[u].push_back(m);
        adj[v].push_back(m + 1);
        m += 2;
    }

    int bfs() {
        vistoken++;
        queue<int> fila;
        fila.push(s);
        vector<int> pego(n, -1);
        while (!fila.empty()) {
            int u = fila.front();
            if (u == t) break;
            fila.pop();
            visto[u] = vistoken;
            for (int id : adj[u]) {
                if (edges[id].cap - edges[id].flow < 1) continue;
                int v = edges[id].v;
                if (visto[v] == -1) continue;
                fila.push(v);
                pego[v] = id;
            }
        }
        if (pego[t] == -1) return 0;
        long long f = INF;
        for (int id = pego[t]; id != -1; id = pego[edges[id].u])
            f = min(f, edges[id].cap - edges[id].flow);
        for (int id = pego[t]; id != -1; id = pego[edges[id].u]) {
            edges[id].flow += f;
            edges[id ^ 1].flow -= f;
        }
        return f;
    }

    long long flow() {
        long long maxflow = 0;
        while (long long f = bfs()) maxflow += f;
        return maxflow;
    }
};
\end{lstlisting}
\hfill

Codigo: MinCostMaxFlow.cpp

\begin{lstlisting}[language=C++]
struct MinCostMaxFlow {
    int n, s, t, m = 0;
    ll maxflow = 0, mincost = 0;
    vector<FlowEdge> edges;
    vector<vector<int>> adj;

    MinCostMaxFlow(int n, int s, int t) : n(n), s(s), t(t) { adj.resize(n); }

    void add_edge(int u, int v, ll cap, ll cost) {
        edges.emplace_back(u, v, cap, cost);
        edges.emplace_back(v, u, 0, -cost);
        adj[u].push_back(m);
        adj[v].push_back(m + 1);
        m += 2;
    }

    bool spfa() {
        vector<int> pego(n, -1);
        vector<ll> dis(n, INF);
        vector<bool> inq(n, false);
        queue<int> fila;
        fila.push(s);
        dis[s] = 0;
        inq[s] = 1;
        while (!fila.empty()) {
            int u = fila.front();
            fila.pop();
            inq[u] = false;
            for (int id : adj[u]) {
                if (edges[id].cap - edges[id].flow < 1) continue;
                int v = edges[id].v;
                if (dis[v] > dis[u] + edges[id].cost) {
                    dis[v] = dis[u] + edges[id].cost;
                    pego[v] = id;
                    if (!inq[v]) {
                        inq[v] = true;
                        fila.push(v);
                    }
                }
            }
        }

        if (pego[t] == -1) return 0;
        ll f = INF;
        for (int id = pego[t]; id != -1; id = pego[edges[id].u]) {
            f = min(f, edges[id].cap - edges[id].flow);
            mincost += edges[id].cost;
        }
        for (int id = pego[t]; id != -1; id = pego[edges[id].u]) {
            edges[id].flow += f;
            edges[id ^ 1].flow -= f;
        }
        maxflow += f;
        return 1;
    }

    ll flow() {
        while (spfa());
        return maxflow;
    }
};
\end{lstlisting}
\hfill

Codigo: Dinic.cpp

\begin{lstlisting}[language=C++]
typedef long long ll;

const ll INF = 1e18;

struct FlowEdge {
    int u, v;
    ll cap, flow = 0;
    FlowEdge(int u, int v, ll cap) : u(u), v(v), cap(cap) { }
};

struct Dinic {
    vector<FlowEdge> edges;
    vector<vector<int>> adj;
    int n, s, t, m = 0;
    vector<int> level, ptr;
    queue<int> q;

    Dinic(int n, int s, int t) : n(n), s(s), t(t) {
        adj.resize(n);
        level.resize(n);
        ptr.resize(n);
    }

    void add_edge(int u, int v, ll cap) {
        edges.emplace_back(u, v, cap);
        edges.emplace_back(v, u, 0);
        adj[u].push_back(m);
        adj[v].push_back(m + 1);
        m += 2;
    }

    bool bfs() {
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            for (int id : adj[u]) {
                if (edges[id].cap - edges[id].flow < 1) continue;
                int v = edges[id].v;
                if (level[v] != -1) continue;
                level[v] = level[u] + 1;
                q.push(v);
            }
        }
        return level[t] != -1;
    }

    ll dfs(int u, ll f) {
        if (f == 0) return 0;
        if (u == t) return f;
        for (int &cid = ptr[u]; cid < (int)adj[u].size(); cid++) {
            int id = adj[u][cid];
            int v = edges[id].v;
            if (level[u] + 1 != level[v] || edges[id].cap - edges[id].flow < 1) continue;
            ll tr = dfs(v, min(f, edges[id].cap - edges[id].flow));
            if (tr == 0) continue;
            edges[id].flow += tr;
            edges[id ^ 1].flow -= tr;
            return tr;
        }
        return 0;
    }

    ll flow() {
        ll maxflow = 0;
        while (true) {
            fill(level.begin(), level.end(), -1);
            level[s] = 0;
            q.push(s);
            if (!bfs()) break;
            fill(ptr.begin(), ptr.end(), 0);
            while (ll f = dfs(s, INF)) maxflow += f;
        }
        return maxflow;
    }
};
\end{lstlisting}
\hfill

\section{HLD}


Técnica utilizada para decompor uma árvore em cadeias, e assim realizar operações de caminho e subárvore em $\mathcal{O}(\log N \cdot g(N))$, onde $g(N)$ é a complexidade da operação. Esta implementação suporta queries de soma e update de soma/atribuição, pois usa a estrutura de dados \texttt{Segment Tree Lazy} desse almanaque, fazendo assim com que updates e consultas sejam  $\mathcal{O}(\log^2 N)$. A estrutura (bem como a operação feita nela) pode ser facilmente trocada, basta alterar o código da \texttt{Segment Tree Lazy}, ou ainda, utilizar outra estrutura de dados, como uma \texttt{Sparse Table}, caso você tenha queries de mínimo/máximo sem updates, por exemplo. Ao mudar a estrutura, pode ser necessário adaptar os métodos \texttt{query} e \texttt{update} da HLD.



A HLD pode ser feita com os valores estando tanto nos nodos quanto nas arestas, consulte os métodos \texttt{build} do código para mais detalhes.



A construção da HLD é feita em $\mathcal{O}(N + b(N))$, onde $b(N)$ é a complexidade de construir a estrutura de dados utilizada.
\hfill

Codigo: HLD.cpp

\begin{lstlisting}[language=C++]
const int N = 3e5 + 5;

vector<int> adj[N];
int sz[N], pos[N], par[N], head[N];

namespace HLD {
    int t;
    bool e = 0; // flag pra dizer se eh de aresta ou nao
    SegTree ds; // pode usar qualquer estrutura de dados aqui

    void dfs_sz(int u, int p = -1) {
        sz[u] = 1;
        for (int &v : adj[u]) {
            if (v != p) {
                dfs_sz(v, u);
                sz[u] += sz[v];
                if (sz[v] > sz[adj[u][0]] || adj[u][0] == p) swap(v, adj[u][0]);
            }
        }
    }
    void dfs_hld(int u, int p = -1) {
        pos[u] = t++;
        for (int v : adj[u]) {
            if (v != p) {
                par[v] = u;
                head[v] = (v == adj[u][0] ? head[u] : v);
                dfs_hld(v, u);
            }
        }
    }
    void build_hld(int u) {
        dfs_sz(u);
        t = 0;
        par[u] = u;
        head[u] = u;
        dfs_hld(u);
    }

    void build(int root, vector<ll> v) {
        // usar esse build pra iniciar com valores nos nodos
        // (para iniciar vazia, passar o vetor com valores neutros)
        build_hld(root);
        vector<ll> aux(v.size());
        for (int i = 0; i < (int)v.size(); i++) aux[pos[i]] = v[i];
        ds.build(aux);
    }

    void build(int root, vector<tuple<int, int, ll>> edges) {
        // usar esse build se os valores estiverem nas arestas
        for (auto [u, v, w] : edges) {
            adj[u].push_back(v);
            adj[v].push_back(u);
        }
        build_hld(root);
        e = 1;
        assert(edges.size() >= 1);
        vector<ll> aux(edges.size() - 1);
        for (auto [u, v, w] : edges) {
            if (pos[u] > pos[v]) swap(u, v);
            aux[pos[v]] = w;
        }
        ds.build(aux);
    }

    ll query(int u, int v) {
        if (e && u == v) return ds.neutral;
        if (pos[u] > pos[v]) swap(u, v);
        if (head[u] == head[v]) {
            return ds.query(pos[u] + e, pos[v]);
        } else {
            ll qv = ds.query(pos[head[v]], pos[v]);
            ll qu = query(u, par[head[v]]);
            return ds.merge(qu, qv);
        }
    }
    ll query_subtree(int u) {
        if (e && sz[u] == 1) return ds.neutral;
        return ds.query(pos[u] + e, pos[u] + sz[u] - 1);
    }

    void update(int u, int v, ll k, bool replace = false) {
        if (e && u == v) return;
        if (pos[u] > pos[v]) swap(u, v);
        if (head[u] == head[v]) {
            ds.update(pos[u] + e, pos[v], k, replace);
        } else {
            ds.update(pos[head[v]], pos[v], k, replace);
            update(u, par[head[v]], k, replace);
        }
    }
    void update_subtree(int u, ll k, bool replace = false) {
        if (e && sz[u] == 1) return;
        ds.update(pos[u] + e, pos[u] + sz[u] - 1, k, replace);
    }

    int lca(int u, int v) {
        if (pos[u] > pos[v]) swap(u, v);
        return head[u] == head[v] ? u : lca(u, par[head[v]]);
    }
}\end{lstlisting}
\hfill

\section{Inverse Graph}


Algoritmo que encontra as componentes conexas quando se é dado o grafo complemento.



Resolve problemas em que se deseja encontrar as componentes conexas quando são dadas as arestas que não pertencem ao grafo, em $\mathcal{O}(N \cdot \log N + N \cdot \log M)$.
\hfill

Codigo: inverse\_graph.cpp

\begin{lstlisting}[language=C++]
set<int> nodes;
vector<set<int>> adj;

void bfs(int s) {
    queue<int> f;
    f.push(s);
    nodes.erase(s);
    set<int> aux;
    while (!f.empty()) {
        int x = f.front();
        f.pop();
        for (int y : nodes)
            if (adj[x].count(y) == 0) aux.insert(y);
        for (int y : aux) {
            f.push(y);
            nodes.erase(y);
        }
        aux.clear();
    }
}
\end{lstlisting}
\hfill

\section{Kruskal}


Algoritimo que utiliza DSU (Disjoint Set Union, descrita na seção de Estrutura de Dados) para encontrar a MST (Minimum Spanning Tree) de um grafo em $\mathcal{O}(E \log E)$.



A Minimum Spanning Tree é a árvore geradora mínima de um grafo, ou seja, um conjunto de arestas que conecta todos os nodos do grafo com o menor custo possível.



Propriedades importantes da MST:



\begin{itemize}
\item É uma árvore! :O
\item Entre quaisquer dois nodos $u$ e $v$ do grafo, a MST minimiza a maior aresta no caminho de $u$ a $v$.
\end{itemize}



Ideia do Kruskal: ordenar as arestas do grafo por peso e, para cada aresta, adicionar ela à MST se ela não forma um ciclo com as arestas já adicionadas.
\hfill

Codigo: kruskal.cpp

\begin{lstlisting}[language=C++]
vector<tuple<int, int, int>> edges; // {u, v, w}

void kruskal(int n) {
    DSU dsu(n); // DSU da seção Estruturas de Dados

    sort(edges.begin(), edges.end(), [](auto a, auto b) {
        return get<2>(a) < get<2>(b);
    });

    for (auto [u, v, w] : edges) {
        if (dsu.unite(u, v)) {
            // edge u-v is in the MST
        }
    }
}
\end{lstlisting}
\hfill

\section{LCA}


Algoritmo para computar Lowest Common Ancestor usando Euler Tour e Sparse Table (descrita na seção Estruturas de Dados), com pré-processamento em $\mathcal{O}(N \log N)$ e consulta em $\mathcal{O}(1)$.

\hfill

Codigo: lca.cpp

\begin{lstlisting}[language=C++]
const int N = 5e5 + 5;
int timer, tin[N];
vector<int> adj[N];
vector<pair<int, int>> prof;

struct SparseTable {
    int n, LG;
    using T = pair<int, int>;
    vector<vector<T>> st;
    T merge(T a, T b) { return min(a, b); }
    const T neutral = {INT_MAX, -1};
    void build(const vector<T> &v) {
        n = (int)v.size();
        LG = 32 - __builtin_clz(n);
        st = vector<vector<T>>(LG, vector<T>(n));
        for (int i = 0; i < n; i++) st[0][i] = v[i];
        for (int i = 0; i < LG - 1; i++)
            for (int j = 0; j + (1 << i) < n; j++)
                st[i + 1][j] = merge(st[i][j], st[i][j + (1 << i)]);
    }
    T query(int l, int r) {
        if (l > r) return neutral;
        int i = 31 - __builtin_clz(r - l + 1);
        return merge(st[i][l], st[i][r - (1 << i) + 1]);
    }
} st_lca;

void et_dfs(int u, int p, int h) {
    tin[u] = timer++;
    prof.emplace_back(h, u);
    for (int v : adj[u]) {
        if (v != p) {
            et_dfs(v, u, h + 1);
            prof.emplace_back(h, u);
        }
    }
    timer++;
}

int lca(int u, int v) {
    int l = tin[u], r = tin[v];
    if (l > r) swap(l, r);
    return st_lca.query(l, r).second;
}

void build() {
    timer = 0;
    prof.clear();
    et_dfs(0, -1, 0);
    st_lca.build(prof);
}\end{lstlisting}
\hfill

\section{Matching}
\subsection{Hungaro}


Resolve o problema de Matching para uma matriz \texttt{A[n][m]}, onde $n \leq m$.



A implementação minimiza os custos, para maximizar basta multiplicar os pesos por $-1$.



\textbf{A matriz de entrada precisa ser indexada em 1}



O vetor \texttt{result} guarda os pares do matching.



Complexidade de tempo: $\mathcal{O}(n^2 * m)$

\hfill

Codigo: hungarian.cpp

\begin{lstlisting}[language=C++]
const ll INF = 1e18 + 18;

vector<pair<int, int>> result;

ll hungarian(int n, int m, vector<vector<int>> &A) {
    vector<int> u(n + 1), v(m + 1), p(m + 1), way(m + 1);
    for (int i = 1; i <= n; i++) {
        p[0] = i;
        int j0 = 0;
        vector<int> minv(m + 1, INF);
        vector<char> used(m + 1, false);
        do {
            used[j0] = true;
            ll i0 = p[j0], delta = INF, j1;
            for (int j = 1; j <= m; j++) {
                if (!used[j]) {
                    int cur = A[i0][j] - u[i0] - v[j];
                    if (cur < minv[j]) minv[j] = cur, way[j] = j0;
                    if (minv[j] < delta) delta = minv[j], j1 = j;
                }
            }
            for (int j = 0; j <= m; j++)
                if (used[j]) u[p[j]] += delta, v[j] -= delta;
                else minv[j] -= delta;
            j0 = j1;
        } while (p[j0] != 0);
        do {
            int j1 = way[j0];
            p[j0] = p[j1];
            j0 = j1;
        } while (j0);
    }
    for (int i = 1; i <= m; i++) result.emplace_back(p[i], i);
    return -v[0];
}
\end{lstlisting}
\hfill

\section{Pontes}


Algoritmo que acha pontes em um grafo utilizando DFS. $\mathcal{O}(V + E)$. Pontes são aresta cuja remoção aumenta o número de componentes conexas do grafo.



Nesse código também há uma função que acha componentes aresta-biconexas, que são componentes que para se desconectar é necessário remover pelo menos duas arestas. Para obter essas componentes, basta achar as pontes e contrair o resto do grafo, o resultado é uma árvore.
\hfill

Codigo: find\_bridges.cpp

\begin{lstlisting}[language=C++]
const int N = 3e5 + 5;
int n, timer;
vector<int> adj[N];
int tin[N], low[N];

void dfs(int u, int p = -1) {
    low[u] = tin[u] = ++timer;
    for (int v : adj[u]) {
        if (tin[v] != 0 && v != p) {
            low[u] = min(low[u], tin[v]);
        } else if (v != p) {
            dfs(v, u);
            low[u] = min(low[u], low[v]);
        }
    }
    if (p != -1 && low[u] == tin[u]) {
        // edge (p, u) is a bridge
    }
}

void find_bridges() {
    timer = 0;
    for (int i = 0; i < n; i++) tin[i] = low[i] = 0;
    for (int i = 0; i < n; i++)
        if (tin[i] == 0) dfs(i);
}

// Edge Biconnected Components (requer todo o código acima)

int ebcc[N], ncc = 0;
vector<int> adjbcc[N];

void dfs_ebcc(int u, int p, int cc) {
    if (p != -1 && low[u] == tin[u]) cc = ++ncc;
    ebcc[u] = cc;
    for (int v : adj[u])
        if (ebcc[v] == -1) dfs_ebcc(v, u, cc);
}

void build_ebcc_graph() {
    find_bridges();
    for (int i = 0; i < n; i++) ebcc[i] = -1;
    for (int i = 0; i < n; i++) { // should follow the same order of find_bridges dfs
        if (ebcc[i] == -1) {
            dfs_ebcc(i, -1, ncc);
            ++ncc;
        }
    }
    // Opcao 1 - constroi o grafo comprimido passando por todas as edges
    for (int u = 0; u < n; u++) {
        for (auto v : adj[u]) {
            if (ebcc[u] != ebcc[v]) {
                adjbcc[ebcc[u]].emplace_back(ebcc[v]);
            } else {
                // faz algo
            }
        }
    }
    // Opcao 2 - constroi o grafo comprimido passando so pelas pontes
    // for (auto [u, v] : bridges) {
    //     adjbcc[ebcc[u]].emplace_back(ebcc[v]);
    //     adjbcc[ebcc[v]].emplace_back(ebcc[u]);
    // }
}\end{lstlisting}
\hfill

\section{Pontos de Articulacao}


Algoritmo que acha pontos de articulação em um grafo utilizando DFS. $\mathcal{O}(V + E)$. Pontos de articulação são nodos cuja remoção aumenta o número de componentes conexas do grafo.
\hfill

Codigo: articulation\_points.cpp

\begin{lstlisting}[language=C++]
const int N = 3e5 + 5;
int n, timer;
vector<int> adj[N];
int tin[N], low[N];

void dfs(int u, int p = -1) {
    low[u] = tin[u] = ++timer;
    int child = 0;
    for (int v : adj[u]) {
        if (tin[v] != 0 && v != p) {
            low[u] = min(low[u], tin[v]);
        } else if (v != p) {
            dfs(v, u);
            low[u] = min(low[u], low[v]);
            if (p != -1 && low[v] >= tin[u]) {
                // vertex u is an articulation point
            }
            child++;
        }
    }
    if (p == -1 && child > 1) {
        // vertex u is an articulation point
    }
}

void find_articulation_points() {
    timer = 0;
    for (int i = 0; i < n; i++) tin[i] = low[i] = 0;
    for (int i = 0; i < n; i++)
        if (tin[i] == 0) dfs(i);
}
\end{lstlisting}
\hfill

\section{Shortest Paths}
\subsection{01 BFS}


Computa o menor caminho entre nodos de um grafo com arestas de peso 0 ou 1.



Dado um nodo $s$, computa o menor caminho de $s$ para todos os outros nodos em $\mathcal{O}(V + E)$.



Muito semelhante a uma BFS, mas usa uma \texttt{deque} (fila dupla) ao invés de uma fila comum.



\textbf{Importante}: As arestas só podem ter peso 0 ou 1.
\hfill

Codigo: bfs01.cpp

\begin{lstlisting}[language=C++]
const int N = 3e5 + 5;
const int INF = 1e9;

int n;
vector<pair<int, int>> adj[N];

vector<int> bfs01(int s) {
    vector<int> dist(n, INF);
    deque<int> q;
    dist[s] = 0;
    q.emplace_back(s);
    while (!q.empty()) {
        int u = q.front();
        q.pop_front();
        for (auto [w, v] : adj[u]) {
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                if (w == 0) q.push_front(v);
                else q.push_back(v);
            }
        }
    }
    return dist;
}\end{lstlisting}
\hfill

\subsection{BFS}


Computa o menor caminho entre nodos de um grafo com arestas de peso 1.



Dado um nodo $s$, computa o menor caminho de $s$ para todos os outros nodos em $\mathcal{O}(V + E)$.



\textbf{Importante}: Todas arestas do grafo devem ter peso 1.
\hfill

Codigo: bfs.cpp

\begin{lstlisting}[language=C++]
const int N = 3e5 + 5;

int n;
vector<int> adj[N];

vector<int> bfs(int s) {
    vector<int> dist(n, -1);
    queue<int> q;
    dist[s] = 0;
    q.emplace(s);
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (auto v : adj[u]) {
            if (dist[v] == -1) {
                dist[v] = dist[u] + 1;
                q.emplace(v);
            }
        }
    }
    return dist;
}\end{lstlisting}
\hfill

\subsection{Bellman Ford}


Encontra o caminho mais curto entre um nodo e todos os outros nodos de um grafo em $\mathcal{O}(|V| * |E|)$.



\textbf{Importante}: Detecta ciclos negativos.

\hfill

Codigo: bellman\_ford.cpp

\begin{lstlisting}[language=C++]
const ll INF = 1e18;

int n;
vector<tuple<int, int, int>> edges;

vector<ll> bellman_ford(int s) {
    vector<ll> dist(n, INF);
    dist[s] = 0;
    for (int i = 0; i < n; i++) {
        for (auto [u, v, w] : edges)
            if (dist[u] < INF) dist[v] = min(dist[v], dist[u] + w);
    }
    for (int i = 0; i < n; i++) {
        for (auto [u, v, w] : edges)
            if (dist[u] < INF && dist[u] + w < dist[v]) dist[v] = -INF;
    }
    // dist[u] = -INF se tem um ciclo negativo que chega em u
    return dist;
}
\end{lstlisting}
\hfill

\subsection{Dijkstra}


Computa o menor caminho entre nodos de um grafo com pesos quaisquer nas arestas.



Dado um nodo $s$, computa o menor caminho de $s$ para todos os outros nodos em $\mathcal{O}((V + E) \cdot \log E)$.



Muito semelhante a uma BFS, mas usa uma fila de prioridade ao invés de uma fila comum.



\textbf{Importante}: O grafo não pode conter arestas de peso negativo.
\hfill

Codigo: dijkstra.cpp

\begin{lstlisting}[language=C++]
const int N = 3e5 + 5;
const ll INF = 1e18;

int n;
vector<pair<int, int>> adj[N];

vector<ll> dijkstra(int s) {
    vector<ll> dist(n, INF);
    using T = pair<ll, int>;
    priority_queue<T, vector<T>, greater<>> pq;
    dist[s] = 0;
    pq.emplace(dist[s], s);
    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();
        if (d != dist[u]) continue;
        for (auto [w, v] : adj[u]) {
            if (dist[v] > d + w) {
                dist[v] = d + w;
                pq.emplace(dist[v], v);
            }
        }
    }
    return dist;
}
\end{lstlisting}
\hfill

\subsection{Floyd Warshall}


Algoritmo que encontra o menor caminho entre todos os pares de nodos de um grafo com pesos em $\mathcal{O}(N^3)$.



A ideia do algoritmo é: para cada nodo $k$, passamos por todos os pares de nodos $(i, j)$ e verificamos se é mais curto passar por $k$ para ir de $i$ a $j$ do que o caminho atual de $i$ a $j$. Se for, atualizamos o caminho.
\hfill

Codigo: floyd\_warshall.cpp

\begin{lstlisting}[language=C++]
const int N = 3e3 + 5;
const ll INF = 1e18;
int n;

ll adj[N][N]; // adj[u][v] = peso da aresta u-v, INF se não existe
ll dist[N][N];

void floydwarshall() {
    for (int u = 0; u < n; u++)
        for (int v = 0; v < n; v++) dist[u][v] = adj[u][v];
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
    }
}\end{lstlisting}
\hfill

\subsection{SPFA}


Encontra o caminho mais curto entre um nodo e todos os outros nodos de um grafo em $\mathcal{O}(|V| * |E|)$. Na prática, é bem mais rápido que o Bellman-Ford.



Detecta ciclos negativos.
\hfill

Codigo: spfa.cpp

\begin{lstlisting}[language=C++]
const int N = 1e4 + 5;
const ll INF = 1e18;

int n;
vector<pair<int, int>> adj[N];

vector<ll> spfa(int s) {
    vector<ll> dist(n, INF);
    vector<int> cnt(n, 0);
    vector<bool> inq(n, false);
    queue<int> q;
    q.push(s);
    inq[s] = true;
    dist[s] = 0;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        inq[u] = false;
        for (auto [w, v] : adj[u]) {
            ll newd = (dist[u] == -INF ? -INF : max(w + dist[u], -INF));
            if (newd < dist[v]) {
                dist[v] = newd;
                if (!inq[v]) {
                    q.push(v);
                    inq[v] = true;
                    cnt[v]++;
                    if (cnt[v] > n) dist[v] = -INF; // negative cycle
                }
            }
        }
    }
    return dist;
}
\end{lstlisting}
\hfill

\section{Stoer–Wagner Min Cut}


Algortimo de Stoer-Wagner para encontrar o corte mínimo de um grafo.



O algoritmo de Stoer-Wagner é um algoritmo para resolver o problema de corte mínimo em grafos não direcionados com pesos não negativos. A ideia essencial deste algoritmo é encolher o grafo mesclando os nodos mais intensos até que o grafo contenha apenas dois conjuntos de nodos combinados



Complexidade de tempo: $\mathcal{O}(V^3)$

\hfill

Codigo: stoer\_wagner.cpp

\begin{lstlisting}[language=C++]
const int MAXN = 555, INF = 1e9 + 7;

int n, e, adj[MAXN][MAXN];
vector<int> bestCut;

int mincut() {
    int bestCost = INF;
    vector<int> v[MAXN];
    for (int i = 0; i < n; i++) v[i].assign(1, i);
    int w[MAXN], sel;
    bool exist[MAXN], added[MAXN];
    memset(exist, true, sizeof(exist));
    for (int phase = 0; phase < n - 1; phase++) {
        memset(added, false, sizeof(added));
        memset(w, 0, sizeof(w));
        for (int j = 0, prev; j < n - phase; j++) {
            sel = -1;
            for (int i = 0; i < n; i++)
                if (exist[i] && !added[i] && (sel == -1 || w[i] > w[sel])) sel = i;
            if (j == n - phase - 1) {
                if (w[sel] < bestCost) {
                    bestCost = w[sel];
                    bestCut = v[sel];
                }
                v[prev].insert(v[prev].end(), v[sel].begin(), v[sel].end());
                for (int i = 0; i < n; i++) adj[prev][i] = adj[i][prev] += adj[sel][i];
                exist[sel] = false;
            } else {
                added[sel] = true;
                for (int i = 0; i < n; i++) w[i] += adj[sel][i];
                prev = sel;
            }
        }
    }
    return bestCost;
}\end{lstlisting}
\hfill

\section{Virtual Tree}


Dado um conjunto de nodos $S$, cria uma árvore com todos os nodos do conjunto e os \texttt{LCA} de todos os pares de nodos

desse conjunto em $\mathcal{O}(|S| \cdot \log  |S|)$.



\textbf{Obs}: Precisa do código de LCA encontrado em \texttt{Grafos/Binary-Lifting-LCA}.

\hfill

Codigo: virtual\_tree.cpp

\begin{lstlisting}[language=C++]
const int N = 3e5 + 5;
#warning nao esqueca de copiar o codigo de LCA
vector<int> vir_tree[N];
vector<int> vir_nodes;

void build_virtual_tree(vector<int> S) {
    int n = (int)S.size();
    sort(S.begin(), S.end(), [&](int i, int j) { return bl::tin[i] < bl::tin[j]; });
    for (int i = 1; i < n; i++) S.emplace_back(bl::lca(S[i - 1], S[i]));
    sort(S.begin(), S.end(), [&](int i, int j) { return bl::tin[i] < bl::tin[j]; });
    S.erase(unique(S.begin(), S.end()), S.end());
    vir_nodes = S;
    n = (int)S.size();
    for (auto u : S) vir_tree[u].clear();
    vector<int> stk = {S[0]};
    for (int i = 1; i < n; i++) {
        int u = S[i];
        while (!bl::ancestor(stk.back(), u)) {
            int v = stk.back();
            stk.pop_back();
            int pai = stk.back();
            vir_tree[pai].emplace_back(v);
        }
        stk.emplace_back(u);
    }
    while (int(stk.size()) >= 2) {
        int u = stk.back();
        stk.pop_back();
        int pai = stk.back();
        vir_tree[pai].emplace_back(u);
    }
}
\end{lstlisting}
\hfill

\newpage

%%%%%%
%
%
% String
%
%
%%%%%%

\chapter{String}

\section{Aho Corasick}


Muito parecido com uma Trie, porém muito mais poderoso. O autômato de Aho-Corasick é um autômato finito determinístico que pode ser construído a partir de um conjunto de padrões. Nesse autômato, para qualquer nodo $u$ do autômato e qualquer caractere $c$ do alfabeto, é possível transicionar de $u$ usando o caractere $c$.



A transição é feita por uma aresta direta de $u$ pra $v$, se a aresta de $u$ pra $v$ estiver marcada com o caractere $c$. Se não, a transição de $u$ com o caractere $c$ é a transição de $link(u)$ com o caractere $c$.



\textbf{Definição}: $link(u)$ é um nodo $v$, tal que o prefixo do autômato ate $v$ é sufixo de $u$, e esse prefixo é o maior possível. Ou seja, $link(u)$ é o maior prefixo do autômato que é sufixo de $u$. Com apenas um padrão inserido, o autômato de Aho-Corasick é a Prefix Function (KMP).



No código, \texttt{cur} é o próximo nodo a ser criado. A root é o nodo $1$.
\hfill

Codigo: aho\_corasick.cpp

\begin{lstlisting}[language=C++]
namespace aho {
    const int M = 3e5 + 1;
    const int K = 26;

    const char norm = 'a';
    inline int get(int c) { return c - norm; }

    int next[M][K], link[M], out_link[M], par[M], cur = 2;
    char pch[M];
    bool out[M];
    vector<int> output[M];

    int node(int p, char c) {
        link[cur] = out_link[cur] = 0;
        par[cur] = p;
        pch[cur] = c;
        return cur++;
    }

    int T = 0;

    int insert(const string &s) {
        int u = 1;
        for (int i = 0; i < (int)s.size(); i++) {
            auto v = next[u][get(s[i])];
            if (v == 0) next[u][get(s[i])] = v = node(u, s[i]);
            u = v;
        }
        out[u] = true;
        output[u].emplace_back(T);
        return T++;
    }

    int go(int u, char c);

    int get_link(int u) {
        if (link[u] == 0) link[u] = par[u] > 1 ? go(get_link(par[u]), pch[u]) : 1;
        return link[u];
    }

    int go(int u, char c) {
        if (next[u][get(c)] == 0) next[u][get(c)] = u > 1 ? go(get_link(u), c) : 1;
        return next[u][get(c)];
    }

    int exit(int u) {
        if (out_link[u] == 0) {
            int v = get_link(u);
            out_link[u] = (out[v] || v == 1) ? v : exit(v);
        }
        return out_link[u];
    }

    bool matched(int u) { return out[u] || exit(u) > 1; }

}\end{lstlisting}
\hfill

\section{Hashing}
\subsection{Hashing}


Hashing polinomial para testar igualdade de strings (ou de vetores). Requer precomputar as potências de um primo, como indicado na função \texttt{precalc}. A implementação está com dois MODS e usa a primitiva \texttt{Mint}, a escolha de usar apenas um MOD ou não usar o \texttt{Mint} vai da sua preferência ou necessidade, se não usar o \texttt{Mint}, trate adequadamente as operações com aritmética modular. A construção é $\mathcal{O}(n)$ e a consulta é $\mathcal{O}(1)$.



\textbf{Obs}: lembrar de chamar a função \texttt{precalc}!



Exemplo de uso:



\begin{lstlisting}[language=C++]
string s = "abacabab";
Hashing h(s);
cout << (h(0, 1) == h(2, 3)) << endl; // 0
cout << (h(0, 1) == h(4, 5)) << endl; // 1
cout << (h(0, 2) == h(4, 6)) << endl; // 1
cout << (h(0, 3) == h(4, 7)) << endl; // 0
cout << (h(0, 3) + h(4, n - 1) * pot[4] == h(0, n - 1)) << endl; // 1, da pra shiftar o hash
string t = "abacabab";
Hashing h2(t);
cout << (h() == h2()) << endl; // 1, pode comparar os hashes diretamente
\end{lstlisting}

\hfill

Codigo: hashing.cpp

\begin{lstlisting}[language=C++]
const int MOD1 = 998244353;
const int MOD2 = (int)(1e9) + 7;
using mint1 = Mint<MOD1>;
using mint2 = Mint<MOD2>;

struct Hash {
    mint1 h1;
    mint2 h2;
    Hash(mint1 _h1 = 0, mint2 _h2 = 0) : h1(_h1), h2(_h2) { }
    bool operator==(Hash o) const { return h1 == o.h1 && h2 == o.h2; }
    bool operator!=(Hash o) const { return h1 != o.h1 || h2 != o.h2; }
    bool operator<(Hash o) const { return h1 == o.h1 ? h2 < o.h2 : h1 < o.h1; }
    Hash operator+(Hash o) const { return {h1 + o.h1, h2 + o.h2}; }
    Hash operator-(Hash o) const { return {h1 - o.h1, h2 - o.h2}; }
    Hash operator*(Hash o) const { return {h1 * o.h1, h2 * o.h2}; }
    Hash operator/(Hash o) const { return {h1 / o.h1, h2 / o.h2}; }
};

const int PRIME = 33333331; // qualquer primo na ordem do alfabeto
const int MAXN = 1e6 + 5;
Hash PR = {PRIME, PRIME};
Hash invPR = {mint1(1) / PRIME, mint2(1) / PRIME};
Hash pot[MAXN], invpot[MAXN];

void precalc() {
    pot[0] = invpot[0] = Hash(1, 1);
    for (int i = 1; i < MAXN; i++) {
        pot[i] = pot[i - 1] * PR;
        invpot[i] = invpot[i - 1] * invPR;
    }
}

struct Hashing {
    int N;
    vector<Hash> hsh;
    Hashing() { }
    Hashing(string s) : N((int)s.size()), hsh(N + 1) {
        for (int i = 0; i < N; i++) {
            int c = (int)s[i];
            hsh[i + 1] = hsh[i] + (pot[i + 1] * Hash(c, c));
        }
    }
    Hash operator()(int l = 0, int r = -1) const {
#warning Chamou o precalc()?
        // se ja chamou o precalc() pode apagar essa linha de cima
        if (r == -1) r = N - 1;
        return (hsh[r + 1] - hsh[l]) * invpot[l];
    }
};
\end{lstlisting}
\hfill

\subsection{Hashing Dinâmico}


Hashing polinomial para testar igualdade de strings (ou de vetores). Requer precomputar as potências de um primo, como indicado na função \texttt{precalc}. A implementação está com dois MODS e usa a primitiva \texttt{Mint}, a escolha de usar apenas um MOD ou não usar o \texttt{Mint} vai da sua preferência ou necessidade, se não usar o \texttt{Mint}, trate adequadamente as operações com aritmética modular.

Essa implementação suporta updates pontuais, utilizando-se de uma \texttt{Fenwick Tree} para isso. A construção é $\mathcal{O}(n)$, consultas e updates são $\mathcal{O}(\log n)$.



\textbf{Obs}: lembrar de chamar a função \texttt{precalc}!



Exemplo de uso:



\begin{lstlisting}[language=C++]
string s = "abacabab";
DynamicHashing a(s);
cout << (a(0, 1) == a(2, 3)) << endl; // 0
cout << (a(0, 1) == a(4, 5)) << endl; // 1
a.update(0, 'c');
cout << (a(0, 1) == a(4, 5)) << endl; // 0
\end{lstlisting}

\hfill

Codigo: dynamic\_hashing.cpp

\begin{lstlisting}[language=C++]
const int MOD1 = 998244353;
const int MOD2 = 1e9 + 7;
using mint1 = Mint<MOD1>;
using mint2 = Mint<MOD2>;

struct Hash {
    mint1 h1;
    mint2 h2;
    Hash() { }
    Hash(mint1 _h1, mint2 _h2) : h1(_h1), h2(_h2) { }
    bool operator==(Hash o) const { return h1 == o.h1 && h2 == o.h2; }
    bool operator!=(Hash o) const { return h1 != o.h1 || h2 != o.h2; }
    bool operator<(Hash o) const { return h1 == o.h1 ? h2 < o.h2 : h1 < o.h1; }
    Hash operator+(Hash o) const { return {h1 + o.h1, h2 + o.h2}; }
    Hash operator-(Hash o) const { return {h1 - o.h1, h2 - o.h2}; }
    Hash operator*(Hash o) const { return {h1 * o.h1, h2 * o.h2}; }
    Hash operator/(Hash o) const { return {h1 / o.h1, h2 / o.h2}; }
};

const int PRIME = 1001003; // qualquer primo na ordem do alfabeto
const int MAXN = 1e6 + 5;
Hash PR = {PRIME, PRIME};
Hash invPR = {mint1(1) / PRIME, mint2(1) / PRIME};
Hash pot[MAXN], invpot[MAXN];
void precalc() {
    pot[0] = invpot[0] = Hash(1, 1);
    for (int i = 1; i < MAXN; i++) {
        pot[i] = pot[i - 1] * PR;
        invpot[i] = invpot[i - 1] * invPR;
    }
}

struct DynamicHashing {
    int N;
    FenwickTree<Hash> hsh;
    DynamicHashing() { }
    DynamicHashing(string s) : N(int(s.size())) {
        vector<Hash> v(N);
        for (int i = 0; i < N; i++) {
            int c = (int)s[i];
            v[i] = pot[i + 1] * Hash(c, c);
        }
        hsh = FenwickTree<Hash>(v);
    }
    Hash operator()(int l, int r) { return hsh.query(l, r) * invpot[l]; }
    void update(int i, char ch) {
        int c = (int)ch;
        hsh.updateSet(i, pot[i + 1] * Hash(c, c));
    }
};
\end{lstlisting}
\hfill

\section{Lyndon}


Strings em decomposição única em subcadeias que são ordenadas lexicograficamente e não podem ser mais reduzidas.



\textbf{Duval} 



Gera a Lyndon Factorization de uma string



* Complexidade de tempo: $\mathcal{O}(N)$



\textbf{Min Cyclic Shift} 



Gera a menor rotação circular da string original que pode ser obtida por meio de deslocamentos cíclicos dos caracteres.



* Complexidade de tempo: $\mathcal{O}(N)$
\hfill

Codigo: min\_cyclic\_shift.cpp

\begin{lstlisting}[language=C++]
string min_cyclic_shift(string s) {
    s += s;
    int n = s.size();
    int i = 0, ans = 0;
    while (i < n / 2) {
        ans = i;
        int j = i + 1, k = i;
        while (j < n && s[k] <= s[j]) {
            if (s[k] < s[j]) k = i;
            else k++;
            j++;
        }
        while (i <= k) i += j - k;
    }
    return s.substr(ans, n / 2);
}
\end{lstlisting}
\hfill

Codigo: duval.cpp

\begin{lstlisting}[language=C++]
vector<string> duval(string const &s) {
    int n = s.size();
    int i = 0;
    vector<string> factorization;
    while (i < n) {
        int j = i + 1, k = i;
        while (j < n && s[k] <= s[j]) {
            if (s[k] < s[j]) k = i;
            else k++;
            j++;
        }
        while (i <= k) {
            factorization.push_back(s.substr(i, j - k));
            i += j - k;
        }
    }
    return factorization;
}
\end{lstlisting}
\hfill

\section{Manacher}


O algoritmo de manacher encontra todos os palíndromos de uma string em $\mathcal{O}(n)$. Para cada centro, ele conta quantos palíndromos de tamanho ímpar e par existem (nos vetores \texttt{d1} e \texttt{d2} respectivamente). O método \texttt{solve} computa os palíndromos e retorna o número de substrings palíndromas. O método \texttt{query} retorna se a substring \texttt{s[i...j]} é palíndroma em $\mathcal{O}(1)$.
\hfill

Codigo: manacher.cpp

\begin{lstlisting}[language=C++]
struct Manacher {
    int n;
    ll count;
    vector<int> d1, d2, man;
    ll solve(const string &s) {
        n = int(s.size()), count = 0;
        solve_odd(s);
        solve_even(s);
        man.assign(2 * n - 1, 0);
        for (int i = 0; i < n; i++) man[2 * i] = 2 * d1[i] - 1;
        for (int i = 0; i < n - 1; i++) man[2 * i + 1] = 2 * d2[i + 1];
        return count;
    }
    void solve_odd(const string &s) {
        d1.assign(n, 0);
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) k++;
            count += d1[i] = k--;
            if (i + k > r) l = i - k, r = i + k;
        }
    }
    void solve_even(const string &s) {
        d2.assign(n, 0);
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : min(d2[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s[i - k - 1] == s[i + k]) k++;
            count += d2[i] = k--;
            if (i + k > r) l = i - k - 1, r = i + k;
        }
    }
    bool query(int i, int j) {
        assert(man.size());
        return man[i + j] >= j - i + 1;
    }
} mana;\end{lstlisting}
\hfill

\section{Patricia Tree}


Estrutura de dados que armazena strings e permite consultas por prefixo, muito similar a uma Trie. Todas as operações são $\mathcal{O}(|s|)$.



\textbf{Obs}: Não aceita elementos repetidos.



Implementação PB-DS, extremamente curta e confusa:



Exemplo de uso:



\begin{lstlisting}[language=C++]
patricia_tree pat;
pat.insert("exemplo");
pat.erase("exemplo");
pat.find("exemplo") != pat.end(); // verifica existência
auto match = pat.prefix_range("ex"); // pega palavras que começam com "ex"
for (auto it = match.first; it != match.second; ++it); // percorre match
pat.lower_bound("ex"); // menor elemento lexicográfico maior ou igual a "ex"
pat.upper_bound("ex"); // menor elemento lexicográfico maior que "ex"
\end{lstlisting}

\hfill

Codigo: patricia\_tree.cpp

\begin{lstlisting}[language=C++]
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/trie_policy.hpp>

using namespace __gnu_pbds;
typedef trie<
    string,
    null_type,
    trie_string_access_traits<>,
    pat_trie_tag,
    trie_prefix_search_node_update>
    patricia_tree;
\end{lstlisting}
\hfill

\section{Prefix Function KMP}
\subsection{Automato KMP}


O autômato de KMP computa em $\mathcal{O}(|s| \cdot \Sigma)$ a função de transição de uma string, que é definida por:



$$ nxt[i][c] = \max\{k \mid s[0,k) = s(i-k,i-1]c\} $$



Em outras palavras, $nxt[i][c]$ é o tamanho do maior prefixo de $s$ que é sufixo de $s[0,i-1]c$.



O autômato de KMP é útil para mútiplos pattern matchings, ou seja, dado um padrão $t$, encontrar todas as ocorrências de $t$ em várias strings $s_1, s_2, \dots, s_k$, em $\mathcal{O}(|t| + \sum |s_i|)$. O método \texttt{matching} faz isso.



\textbf{Obs}: utiliza o código do KMP.
\hfill

Codigo: aut\_kmp.cpp

\begin{lstlisting}[language=C++]
struct AutKMP {
    vector<vector<int>> nxt;
    void setString(string s) {
        s += '#';
        nxt.assign(s.size(), vector<int>(26));
        vector<int> p = pi(s);
        for (int c = 0; c < 26; c++) nxt[0][c] = ('a' + c == s[0]);
        for (int i = 1; i < int(s.size()); i++)
            for (int c = 0; c < 26; c++)
                nxt[i][c] = ('a' + c == s[i]) ? i + 1 : nxt[p[i - 1]][c];
    }
    vector<int> matching(string &s, string &t) {
        vector<int> match;
        for (int i = 0, j = 0; i < int(s.size()); i++) {
            j = nxt[j][s[i] - 'a'];
            if (j == int(t.size())) match.push_back(i - j + 1);
        }
        return match;
    }
} aut;
\end{lstlisting}
\hfill

\subsection{KMP}


O algoritmo de Knuth-Morris-Pratt (KMP) computa em $\mathcal{O}(|s|)$ a Prefix Function de uma string, cuja definição é dada por:



$$ p[i] = \max\{k \mid s[0,k) = s(i-k,i]\} $$



Em outras palavras, $p[i]$ é o tamanho do maior prefixo de $s$ que é sufixo próprio de $s[0,i]$.



O KMP é útil para pattern matching, ou seja, encontrar todas as ocorrências de uma string $t$ em uma string $s$, como faz a função \texttt{matching} em $O(|s| + |t|)$.
\hfill

Codigo: kmp.cpp

\begin{lstlisting}[language=C++]
vector<int> pi(string &s) {
    vector<int> p(s.size());
    for (int i = 1, j = 0; i < int(s.size()); i++) {
        while (j > 0 && s[i] != s[j]) j = p[j - 1];
        if (s[i] == s[j]) j++;
        p[i] = j;
    }
    return p;
}

vector<int> matching(string &s, string &t) { // s = texto, t = padrao
    vector<int> p = pi(t), match;
    for (int i = 0, j = 0; i < (int)s.size(); i++) {
        while (j > 0 && s[i] != t[j]) j = p[j - 1];
        if (s[i] == t[j]) j++;
        if (j == (int)t.size()) {
            match.push_back(i - j + 1);
            j = p[j - 1];
        }
    }
    return match;
}\end{lstlisting}
\hfill

\section{Suffix Array}


Estrutura que conterá inteiros que representam os índices iniciais de todos os sufixos ordenados de uma determinada string.



Também constrói a tabela LCP (Longest Common Prefix).



* Complexidade de tempo (Pré-Processamento): $\mathcal{O}(|S| \cdot \log(|S|))$

* Complexidade de tempo (Contar ocorrências de \(S\) em \(T\)): $\mathcal{O}(|S| \cdot \log(|T|))$

\hfill

Codigo: suffix\_array\_busca.cpp

\begin{lstlisting}[language=C++]
pair<int, int> busca(string &t, int i, pair<int, int> &range) {
    int esq = range.first, dir = range.second, L = -1, R = -1;
    while (esq <= dir) {
        int mid = (esq + dir) / 2;
        if (s[sa[mid] + i] == t[i]) L = mid;
        if (s[sa[mid] + i] < t[i]) esq = mid + 1;
        else dir = mid - 1;
    }
    esq = range.first, dir = range.second;
    while (esq <= dir) {
        int mid = (esq + dir) / 2;
        if (s[sa[mid] + i] == t[i]) R = mid;
        if (s[sa[mid] + i] <= t[i]) esq = mid + 1;
        else dir = mid - 1;
    }
    return {L, R};
}
// count ocurences of s on t
int busca_string(string &t) {
    pair<int, int> range = {0, n - 1};
    for (int i = 0; i < t.size(); i++) {
        range = busca(t, i, range);
        if (range.first == -1) return 0;
    }
    return range.second - range.first + 1;
}\end{lstlisting}
\hfill

Codigo: suffix\_array.cpp

\begin{lstlisting}[language=C++]
const int MAX_N = 5e5 + 5;

struct suffix_array {
    string s;
    int n, sum, r, ra[MAX_N], sa[MAX_N], auxra[MAX_N], auxsa[MAX_N], c[MAX_N], lcp[MAX_N];
    void counting_sort(int k) {
        memset(c, 0, sizeof(c));
        for (int i = 0; i < n; i++) c[(i + k < n) ? ra[i + k] : 0]++;
        for (int i = sum = 0; i < max(256, n); i++) sum += c[i], c[i] = sum - c[i];
        for (int i = 0; i < n; i++) auxsa[c[sa[i] + k < n ? ra[sa[i] + k] : 0]++] = sa[i];
        for (int i = 0; i < n; i++) sa[i] = auxsa[i];
    }
    void build_sa() {
        for (int k = 1; k < n; k <<= 1) {
            counting_sort(k);
            counting_sort(0);
            auxra[sa[0]] = r = 0;
            for (int i = 1; i < n; i++) {
                auxra[sa[i]] =
                    (ra[sa[i]] == ra[sa[i - 1]] && ra[sa[i] + k] == ra[sa[i - 1] + k])
                        ? r
                        : ++r;
            }
            for (int i = 0; i < n; i++) ra[i] = auxra[i];
            if (ra[sa[n - 1]] == n - 1) break;
        }
    }
    void build_lcp() {
        for (int i = 0, k = 0; i < n - 1; i++) {
            int j = sa[ra[i] - 1];
            while (s[i + k] == s[j + k]) k++;
            lcp[ra[i]] = k;
            if (k) k--;
        }
    }
    void set_string(string _s) {
        s = _s + '$';
        n = s.size();
        for (int i = 0; i < n; i++) ra[i] = s[i], sa[i] = i;
        build_sa();
        build_lcp();
        // for (int i = 0; i < n; i++)
        // printf("%2d: %s\n", sa[i], s.c_str() +
        // sa[i]);
    }
    int operator[](int i) { return sa[i]; }
} sa;
\end{lstlisting}
\hfill

\section{Suffix Automaton}


Constrói o autômato de sufixos de uma string $S$ em $\mathcal{O}(|S|)$ de forma online. 



\begin{itemize}
\item \texttt{len[u]} é o tamanho da maior string na classe de equivalência de \texttt{u}.
\item \texttt{lnk[u]} é o nodo que representa o maior sufixo de \texttt{u} que não pertence a classe de equivalência de \texttt{u}.
\item \texttt{to[u]} é um array que representa as possivéis transições de um nodo \texttt{u}.
\end{itemize}

\hfill

Codigo: suffix\_automaton.cpp

\begin{lstlisting}[language=C++]
namespace SA {
    const int MAXN = 3e5 + 5;
    const int MAXS = 2 * MAXN + 5;
    array<int, 26> to[MAXS];
    int lnk[MAXS], len[MAXS];
    int last = 1, id = 2;

    void insert(int c) {
        int cur = id++;
        len[cur] = len[last] + 1;
        int p = last;
        while (p && !to[p][c]) {
            to[p][c] = cur;
            p = lnk[p];
        }
        if (p == 0) {
            lnk[cur] = 1;
        } else {
            int s = to[p][c];
            if (len[p] + 1 == len[s]) {
                lnk[cur] = s;
            } else {
                int clone = id++;
                len[clone] = len[p] + 1;
                lnk[clone] = lnk[s];
                to[clone] = to[s];
                while (to[p][c] == s) {
                    to[p][c] = clone;
                    p = lnk[p];
                }
                lnk[s] = lnk[cur] = clone;
            }
        }
        last = cur;
    }
}
\end{lstlisting}
\hfill

\section{Trie}


Estrutura que guarda informações indexadas por palavra.   



Útil encontrar todos os prefixos inseridos anteriormente de uma palavra específica.



* Complexidade de tempo (Update): $\mathcal{O}(|S|)$

* Complexidade de tempo (Consulta de palavra): $\mathcal{O}(|S|)$

\hfill

Codigo: trie.cpp

\begin{lstlisting}[language=C++]
struct trie {
    map<char, int> trie[100005];
    int value[100005];
    int n_nodes = 0;
    void insert(string &s, int v) {
        int id = 0;
        for (char c : s) {
            if (!trie[id].count(c)) trie[id][c] = ++n_nodes;
            id = trie[id][c];
        }
        value[id] = v;
    }
    int get_value(string &s) {
        int id = 0;
        for (char c : s) {
            if (!trie[id].count(c)) return -1;
            id = trie[id][c];
        }
        return value[id];
    }
};
\end{lstlisting}
\hfill

\section{Z function}


O algoritmo abaixo computa o vetor Z de uma string, definido por:



$$ z[i] = \max\{k \mid s[0,k) = s[i,i+k)\} $$



Em outras palavras, $z[i]$ é o tamanho do maior prefixo de $s$ é prefixo de $s[i,|s|-1]$.



É muito semelhante ao KMP em termos de aplicações. Usado principalmente para pattern matching.
\hfill

Codigo: z.cpp

\begin{lstlisting}[language=C++]
vector<int> get_z(string &s) {
    int n = (int)s.size();
    vector<int> z(n);
    for (int i = 1, l = 0, r = 0; i < n; i++) {
        if (i <= r) z[i] = min(r - i + 1, z[i - l]);
        while (i + z[i] < n && s[i + z[i]] == s[z[i]]) z[i]++;
        if (i + z[i] - 1 > r) {
            r = i + z[i] - 1;
            l = i;
        }
    }
    return z;
}

vector<int> matching(string &s, string &t) { // s = texto, t = padrao
    string k = t + "$" + s;
    vector<int> z = get_z(k), match;
    int n = (int)t.size();
    for (int i = n + 1; i < (int)z.size(); i++)
        if (z[i] == n) match.push_back(i - n - 1);
    return match;
}\end{lstlisting}
\hfill

\newpage

%%%%%%
%
%
% Paradigmas
%
%
%%%%%%

\chapter{Paradigmas}

\section{All Submasks}


Percorre todas as submáscaras de uma máscara em $\mathcal{O}(3^n)$.

\hfill

Codigo: all\_submask.cpp

\begin{lstlisting}[language=C++]
int mask;
for (int sub = mask; sub; sub = (sub - 1) & mask) { }
\end{lstlisting}
\hfill

\section{Busca Binaria Paralela}


Faz a busca binária para múltiplas consultas quando a busca binária é muito pesada. A complexidade é $\mathcal{O}((N+Q) \log(N) \cdot \mathcal{O}(F))$, onde $N$ é o tamanho do espaço de busca, $Q$ é o número de consultas, e $\mathcal{O}(F)$ é o custo de avaliação da função.

\hfill

Codigo: busca\_binaria\_paralela.cpp

\begin{lstlisting}[language=C++]

namespace parallel_binary_search {
    typedef tuple<int, int, long long, long long> query; //{value, id, l, r}
    vector<query> queries[1123456];                      // pode ser um mapa se
                                                         // for muito esparso
    long long ans[1123456];                              // definir pro tamanho
                                                         // das queries
    long long l, r, mid;
    int id = 0;
    void set_lim_search(long long n) {
        l = 0;
        r = n;
        mid = (l + r) / 2;
    }

    void add_query(long long v) { queries[mid].push_back({v, id++, l, r}); }

    void advance_search(long long v) {
        // advance search
    }

    bool satisfies(long long mid, int v, long long l, long long r) {
        // implement the evaluation
    }

    bool get_ans() {
        // implement the get ans
    }

    void parallel_binary_search(long long l, long long r) {

        bool go = 1;
        while (go) {
            go = 0;
            int i = 0; // outra logica se for usar
                       // um mapa
            for (auto &vec : queries) {
                advance_search(i++);
                for (auto q : vec) {
                    auto [v, id, l, r] = q;
                    if (l > r) continue;
                    go = 1;
                    // return while satisfies
                    if (satisfies(i, v, l, r)) {
                        ans[i] = get_ans();
                        long long mid = (i + l) / 2;
                        queries[mid] = query(v, id, l, i - 1);
                    } else {
                        long long mid = (i + r) / 2;
                        queries[mid] = query(v, id, i + 1, r);
                    }
                }
                vec.clear();
            }
        }
    }

} // namespace name
\end{lstlisting}
\hfill

\section{Busca Ternaria}


Encontra um ponto ótimo em uma função que pode ser separada em duas funções estritamente monotônicas (por exemplo, parábolas).



\begin{itemize}
\item Complexidade de tempo: $\mathcal{O}(\log(N) \cdot \mathcal{O}(\text{eval}))$, onde \(N\) é o tamanho do espaço de busca e \(\mathcal{O}(\text{eval})\) é o custo de avaliação da função.
\end{itemize}



\textbf{Busca Ternária em Espaço Discreto} 



Encontra um ponto ótimo em uma função que pode ser separada em duas funções estritamente monotônicas (por exemplo, parábolas).

Versão para espaços discretos.



\begin{itemize}
\item Complexidade de tempo: $\mathcal{O}(\log(N) \cdot \mathcal{O}(\text{eval}))$, onde \(N\) é o tamanho do espaço de busca e \(\mathcal{O}(\text{eval})\) é o custo de avaliação da função.
\end{itemize}

\hfill

Codigo: busca\_ternaria.cpp

\begin{lstlisting}[language=C++]

double eval(double mid) {
    // implement the evaluation
}

double ternary_search(double l, double r) {
    int k = 100;
    while (k--) {
        double step = (l + r) / 3;
        double mid_1 = l + step;
        double mid_2 = r - step;

        // minimizing. To maximize use >= to
        // compare
        if (eval(mid_1) <= eval(mid_2)) r = mid_2;
        else l = mid_1;
    }
    return l;
}
\end{lstlisting}
\hfill

Codigo: busca\_ternaria\_discreta.cpp

\begin{lstlisting}[language=C++]

long long eval(long long mid) {
    // implement the evaluation
}

long long discrete_ternary_search(long long l, long long r) {
    long long ans = -1;
    r--; // to not space r
    while (l <= r) {
        long long mid = (l + r) / 2;

        // minimizing. To maximize use >= to
        // compare
        if (eval(mid) <= eval(mid + 1)) {
            ans = mid;
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    return ans;
}
\end{lstlisting}
\hfill

\section{Convex Hull Trick}


Otimização de DP onde se mantém as retas que formam um Convex Hull em uma estrutura que permite consultar qual o melhor valor para um determinado \(x\).



Só funciona quando as retas são monotônicas. Caso não sejam, usar LiChao Tree para guardar as retas.



Complexidade de tempo:



\begin{itemize}
\item Inserir reta: $\mathcal{O}(1)$ amortizado
\item Consultar \(x\): $\mathcal{O}(\log(N))$
\item Consultar \(x\) quando \(x\) tem crescimento monotônico: $\mathcal{O}(1)$
\end{itemize}

\hfill

Codigo: Convex Hull Trick.cpp

\begin{lstlisting}[language=C++]
const ll INF = 1e18 + 18;
bool op(ll a, ll b) {
    return a >= b; // either >= or <=
}
struct line {
    ll a, b;
    ll get(ll x) { return a * x + b; }
    ll intersect(line l) {
        return (l.b - b + a - l.a) / (a - l.a); // rounds up for integer
                                                // only
    }
};
deque<pair<line, ll>> fila;
void add_line(ll a, ll b) {
    line nova = {a, b};
    if (!fila.empty() && fila.back().first.a == a && fila.back().first.b == b) return;
    while (!fila.empty() && op(fila.back().second, nova.intersect(fila.back().first)))
        fila.pop_back();
    ll x = fila.empty() ? -INF : nova.intersect(fila.back().first);
    fila.emplace_back(nova, x);
}
ll get_binary_search(ll x) {
    int esq = 0, dir = fila.size() - 1, r = -1;
    while (esq <= dir) {
        int mid = (esq + dir) / 2;
        if (op(x, fila[mid].second)) {
            esq = mid + 1;
            r = mid;
        } else {
            dir = mid - 1;
        }
    }
    return fila[r].first.get(x);
}
// O(1), use only when QUERIES are monotonic!
ll get(ll x) {
    while (fila.size() >= 2 && op(x, fila[1].second)) fila.pop_front();
    return fila.front().first.get(x);
}
\end{lstlisting}
\hfill

\section{DP de Permutacao}


Otimização do problema do Caixeiro Viajante



* Complexidade de tempo: $\mathcal{O}(n^2 * 2^n)$



Para rodar a função basta setar a matriz de adjacência 'dist' e chamar solve(0,0,n).

\hfill

Codigo: tsp\_dp.cpp

\begin{lstlisting}[language=C++]
const int lim = 17;         // setar para o maximo de itens
long double dist[lim][lim]; // eh preciso dar as
                            // distancias de n para n
long double dp[lim][1 << lim];

int limMask = (1 << lim) - 1; // 2**(maximo de itens) - 1
long double solve(int atual, int mask, int n) {
    if (dp[atual][mask] != 0) return dp[atual][mask];
    if (mask == (1 << n) - 1) {
        return dp[atual][mask] = 0; // o que fazer quando
                                    // chega no final
    }

    long double res = 1e13; // pode ser maior se precisar
    for (int i = 0; i < n; i++) {
        if (!(mask & (1 << i))) {
            long double aux = solve(i, mask | (1 << i), n);
            if (mask) aux += dist[atual][i];
            res = min(res, aux);
        }
    }
    return dp[atual][mask] = res;
}
\end{lstlisting}
\hfill

\section{Divide and Conquer}


Otimização para DP de prefixo quando se pretende separar o vetor em \(K\) subgrupos.    



É preciso fazer a função query(i, j) que computa o custo do subgrupo \[i, j\].

* Complexidade de tempo: $\mathcal{O}(n \cdot k \cdot \log(n) \cdot  \mathcal{O}(\text{query}))$



\textbf{Divide and Conquer com Query on demand} 



Usado para evitar queries pesadas ou o custo de pré-processamento.  

É preciso fazer as funções da estrutura \textbf{janela}, eles adicionam e removem itens um a um como uma janela flutuante.



* Complexidade de tempo: $\mathcal{O}(n \cdot k \cdot \log(n) \cdot \mathcal{O}(\text{update da janela}))$
\hfill

Codigo: dc.cpp

\begin{lstlisting}[language=C++]
namespace DC {
    vi dp_before, dp_cur;
    void compute(int l, int r, int optl, int optr) {
        if (l > r) return;
        int mid = (l + r) >> 1;
        pair<ll, int> best = {0, -1}; // {INF, -1} se quiser minimizar
        for (int i = optl; i <= min(mid, optr); i++) {
            // min() se quiser minimizar
            best = max(best, {(i ? dp_before[i - 1] : 0) + query(i, mid), i});
        }
        dp_cur[mid] = best.first;
        int opt = best.second;
        compute(l, mid - 1, optl, opt);
        compute(mid + 1, r, opt, optr);
    }

    ll solve(int n, int k) {
        dp_before.assign(n + 5, 0);
        dp_cur.assign(n + 5, 0);
        for (int i = 0; i < n; i++) dp_before[i] = query(0, i);
        for (int i = 1; i < k; i++) {
            compute(0, n - 1, 0, n - 1);
            dp_before = dp_cur;
        }
        return dp_before[n - 1];
    }
};
\end{lstlisting}
\hfill

Codigo: dc\_query\_on\_demand.cpp

\begin{lstlisting}[language=C++]
namespace DC {
    struct range { // eh preciso definir a forma
                   // de calcular o range
        vi freq;
        ll sum = 0;
        int l = 0, r = -1;
        void back_l(int v) { // Mover o 'l' do range
                             // para a esquerda
            sum += freq[v];
            freq[v]++;
            l--;
        }
        void advance_r(int v) { // Mover o 'r' do range
                                // para a direita
            sum += freq[v];
            freq[v]++;
            r++;
        }
        void advance_l(int v) { // Mover o 'l' do range
                                // para a direita
            freq[v]--;
            sum -= freq[v];
            l++;
        }
        void back_r(int v) { // Mover o 'r' do range
                             // para a esquerda
            freq[v]--;
            sum -= freq[v];
            r--;
        }
        void clear(int n) { // Limpar range
            l = 0;
            r = -1;
            sum = 0;
            freq.assign(n + 5, 0);
        }
    } s;

    vi dp_before, dp_cur;
    void compute(int l, int r, int optl, int optr) {
        if (l > r) return;
        int mid = (l + r) >> 1;
        pair<ll, int> best = {0, -1}; // {INF, -1} se quiser minimizar

        while (s.l < optl) s.advance_l(v[s.l]);
        while (s.l > optl) s.back_l(v[s.l - 1]);
        while (s.r < mid) s.advance_r(v[s.r + 1]);
        while (s.r > mid) s.back_r(v[s.r]);

        vi removed;
        for (int i = optl; i <= min(mid, optr); i++) {
            best =
                min(best,
                    {(i ? dp_before[i - 1] : 0) + s.sum, i}); // min() se quiser minimizar
            removed.push_back(v[s.l]);
            s.advance_l(v[s.l]);
        }
        for (int rem : removed) s.back_l(v[s.l - 1]);

        dp_cur[mid] = best.first;
        int opt = best.second;
        compute(l, mid - 1, optl, opt);
        compute(mid + 1, r, opt, optr);
    }

    ll solve(int n, int k) {
        dp_before.assign(n, 0);
        dp_cur.assign(n, 0);
        s.clear(n);
        for (int i = 0; i < n; i++) {
            s.advance_r(v[i]);
            dp_before[i] = s.sum;
        }
        for (int i = 1; i < k; i++) {
            s.clear(n);
            compute(0, n - 1, 0, n - 1);
            dp_before = dp_cur;
        }
        return dp_before[n - 1];
    }
};
\end{lstlisting}
\hfill

\section{Exponenciação de Matriz}


Otimização para DP de prefixo quando o valor atual está em função dos últimos $K$ valores já calculados.   



* Complexidade de tempo: $\mathcal{O}(k^3 \cdot \log n)$



É preciso mapear a DP para uma exponenciação de matriz.



\textbf{} 


DP:   



$$ dp[n] = \sum_{i=1}^{k} c[i] \cdot dp[n - i] $$ 



Mapeamento:   



$$ \begin{pmatrix} 0&1&0&0&...&0 \\\ 0&0&1&0&...&0 \\\ 0&0&0&1&...&0 \\\ ...&...&...&...&...&... \\\ c[k]&c[k-1]&c[k-2]&...&c[1]&0 \end{pmatrix}^n \times \begin{pmatrix} dp[0] \\\ dp[1] \\\ dp[2] \\\ ... \\\ dp[k-1] \end{pmatrix} $$



\begin{itemize}
\item --
\end{itemize}

\textbf{} 


Exemplo de DP:   



$$ dp[i] = dp[i-1] + 2 \cdot i^2 + 3 \cdot i + 5 $$



Nesses casos é preciso fazer uma linha para manter cada constante e potência do índice.



Mapeamento:



$$ \begin{pmatrix} 1&5&3&2 \\\ 0&1&0&0 \\\ 0&1&1&0 \\\ 0&1&2&1 \end{pmatrix}^n \times \begin{pmatrix} dp[0]   \\\ 1       \\\ 1       \\\ 1\end {pmatrix} \begin{matrix} \text{mantém } dp[i]   \\\ \text{mantém }1       \\\ \text{mantém }i       \\\ \text{mantém }i^2      \end {matrix} $$



\textbf{} 


Exemplo de DP:



$$ dp[n] = c \cdot \prod_{i=1}^{k} dp[n-i] $$



Nesses casos é preciso trabalhar com o logaritmo e temos o caso padrão:





$$ \log(dp[n]) = \log(c) + \sum_{i=1}^{k} \log(dp[n-i]) $$



Se a resposta precisar ser inteira, deve-se fatorar a constante e os valores inicias e então fazer uma exponenciação para cada fator primo. Depois é só juntar a resposta no final.

\hfill

Codigo: matrix\_exp.cpp

\begin{lstlisting}[language=C++]
using mat = vector<vector<ll>>;
ll dp[100];
mat T;

#define MOD 1000000007

mat operator*(mat a, mat b) {
    mat res(a.size(), vector<ll>(b[0].size()));
    for (int i = 0; i < a.size(); i++) {
        for (int j = 0; j < b[0].size(); j++) {
            for (int k = 0; k < b.size(); k++) {
                res[i][j] += a[i][k] * b[k][j] % MOD;
                res[i][j] %= MOD;
            }
        }
    }
    return res;
}

mat operator^(mat a, ll k) {
    mat res(a.size(), vector<ll>(a.size()));
    for (int i = 0; i < a.size(); i++) res[i][i] = 1;
    while (k) {
        if (k & 1) res = res * a;
        a = a * a;
        k >>= 1;
    }
    return res;
}

// MUDA MUITO DE ACORDO COM O PROBLEMA
// LEIA COMO FAZER O MAPEAMENTO NO README
ll solve(ll exp, ll dim) {
    if (exp < dim) return dp[exp];

    T.assign(dim, vi(dim));
    // TO DO: Preencher a Matriz que vai ser
    // exponenciada T[0][1] = 1; T[1][0] = 1;
    // T[1][1] = 1;

    mat prod = T ^ exp;

    mat vec;
    vec.assign(dim, vi(1));
    for (int i = 0; i < dim; i++) vec[i][0] = dp[i]; // Valores iniciais

    mat ans = prod * vec;
    return ans[0][0];
}
\end{lstlisting}
\hfill

\section{Mo}
\subsection{Mo}


Resolve queries complicadas Offline de forma rápida.  



É preciso manter uma estrutura que adicione e remova elementos nas extremidades de um range (tipo janela).



A complexidade do \texttt{run} é $\mathcal{O}(Q * B + N^2/B)$, onde $B$ é o tamanho do bloco.



Para $B = \sqrt{N}$, a complexidade é $\mathcal{O}((N + Q) * \sqrt{N})$.



Para $B = N / \sqrt Q$, a complexidade é $\mathcal{O}(N * \sqrt{Q})$.

\hfill

Codigo: mo.cpp

\begin{lstlisting}[language=C++]
typedef pair<int, int> ii;
int block_sz; // Better if 'const';

namespace mo {
    struct query {
        int l, r, idx;
        bool operator<(query q) const {
            int _l = l / block_sz;
            int _ql = q.l / block_sz;
            return ii(_l, (_l & 1 ? -r : r)) < ii(_ql, (_ql & 1 ? -q.r : q.r));
        }
    };
    vector<query> queries;

    void build(int n) {
        block_sz = (int)sqrt(n);
        // TODO: initialize data structure
    }
    inline void add_query(int l, int r) {
        queries.push_back({l, r, (int)queries.size()});
    }
    inline void remove(int idx) {
        // TODO: remove value at idx from data
        // structure
    }
    inline void add(int idx) {
        // TODO: add value at idx from data
        // structure
    }
    inline int get_answer() {
        // TODO: extract the current answer of the
        // data structure
        return 0;
    }

    vector<int> run() {
        vector<int> answers(queries.size());
        sort(queries.begin(), queries.end());
        int L = 0;
        int R = -1;
        for (query q : queries) {
            while (L > q.l) add(--L);
            while (R < q.r) add(++R);
            while (L < q.l) remove(L++);
            while (R > q.r) remove(R--);
            answers[q.idx] = get_answer();
        }
        return answers;
    }

};
\end{lstlisting}
\hfill

\subsection{Mo Update}


Resolve queries complicadas Offline de forma rápida.   



Permite que existam \textbf{UPDATES PONTUAIS!}  

É preciso manter uma estrutura que adicione e remova elementos nas extremidades de um range (tipo janela). A complexidade é $\mathcal{O}(Q \cdot \sqrt[3]{N^2})$

\hfill

Codigo: mo\_update.cpp

\begin{lstlisting}[language=C++]
typedef pair<int, int> ii;
typedef tuple<int, int, int> iii;
int block_sz; // Better if 'const';
vector<int> vec;
namespace mo {
    struct query {
        int l, r, t, idx;
        bool operator<(query q) const {
            int _l = l / block_sz;
            int _r = r / block_sz;
            int _ql = q.l / block_sz;
            int _qr = q.r / block_sz;
            return iii(_l, (_l & 1 ? -_r : _r), (_r & 1 ? t : -t)) <
                   iii(_ql, (_ql & 1 ? -_qr : _qr), (_qr & 1 ? q.t : -q.t));
        }
    };
    vector<query> queries;
    vector<ii> updates;

    void build(int n) {
        block_sz = pow(1.4142 * n, 2.0 / 3);
        // TODO: initialize data structure
    }
    inline void add_query(int l, int r) {
        queries.push_back({l, r, (int)updates.size(), (int)queries.size()});
    }
    inline void add_update(int x, int v) { updates.push_back({x, v}); }
    inline void remove(int idx) {
        // TODO: remove value at idx from data
        // structure
    }
    inline void add(int idx) {
        // TODO: add value at idx from data
        // structure
    }
    inline void update(int l, int r, int t) {
        auto &[x, v] = updates[t];
        if (l <= x && x <= r) remove(x);
        swap(vec[x], v);
        if (l <= x && x <= r) add(x);
    }
    inline int get_answer() {
        // TODO: extract the current answer from
        // the data structure
        return 0;
    }

    vector<int> run() {
        vector<int> answers(queries.size());
        sort(queries.begin(), queries.end());
        int L = 0;
        int R = -1;
        int T = 0;
        for (query q : queries) {
            while (T < q.t) update(L, R, T++);
            while (T > q.t) update(L, R, --T);
            while (L > q.l) add(--L);
            while (R < q.r) add(++R);
            while (L < q.l) remove(L++);
            while (R > q.r) remove(R--);
            answers[q.idx] = get_answer();
        }
        return answers;
    }
};
\end{lstlisting}
\hfill

\newpage

%%%%%%
%
%
% Primitivas
%
%
%%%%%%

\chapter{Primitivas}

\section{Modular Int}


O Mint é uma classe que representa um número inteiro módulo número inteiro $\text{MOD}$. Ela é útil para evitar overflow em operações de multiplicação e exponenciação, e também para facilitar a implementações.



Para lembrar as propriedades de aritmética modular, consulte a seção Teórico desse Almanaque.



Para usar o Mint, basta criar um tipo com o valor de $\text{MOD}$ desejado. O valor de $\text{MOD}$ deve ser um número inteiro positivo, podendo ser tanto do tipo \texttt{int} quanto \texttt{long long}.



\begin{lstlisting}[language=C++]
using mint = Mint<7>;
// using mint = Mint<(ll)1e18 + 9> para long long
mint a = 4, b = 3;
mint c = a * b; // c.v == 5
mint d = 1 / a; // d.v == 2, MOD deve ser primo para usar o operador de divisão
mint e = a * d // e.v == 1
a = a + 2; // a.v == 6
a = a + 3; // a.v == 2
a = a ^ 5; // a.v == 4
a = a - 6; // a.v == 5
\end{lstlisting}



\textbf{Obs}: para operador de divisão, o Mint usa o inverso multiplicativo de $a$ baseado no Teorema de Euler (consulte o Teórico para mais detalhes), que é $a^{\text{MOD}-2}$, ou seja, para isso o $\text{MOD}$ deve ser primo.
\hfill

Codigo: mint.cpp

\begin{lstlisting}[language=C++]
template <auto MOD, typename T = decltype(MOD)>
struct Mint {
    using m = Mint<MOD, T>;
    T v;
    Mint(T val = 0) : v(val) { }
    bool operator==(m o) const { return v == o.v; }
    bool operator!=(m o) const { return v != o.v; }
    bool operator<(m o) const { return v < o.v; }
    m pwr(m b, ll e) {
        m res = 1;
        while (e > 0) {
            if (e & 1) res = res * b;
            b = b * b, e >>= 1;
        }
        return res;
    }
    friend m operator-(m a, m b) { return (a.v -= b.v) < 0 ? a.v + MOD : a.v; }
    friend m operator+(m a, m b) { return a - (MOD - b.v); }
    friend m operator*(m a, m b) { return (T)((__int128)a.v * b.v % MOD); }
    // se quiser otimizar constante, ao inves de (__int128) use (ll) se o T for `int`
    friend m operator/(m a, m b) { return a * b.pwr(b, MOD - 2); }
    friend m operator^(m a, ll e) { return a.pwr(a, e); }
};

const int MOD = 998244353;
using mint = Mint<MOD>;\end{lstlisting}
\hfill

\section{Ponto 2D}


Estrutura que representa um ponto no plano cartesiano em duas dimensões. Suporta operações de soma, subtração, multiplicação por escalar, produto escalar, produto vetorial e distância euclidiana. Pode ser usado também para representar um vetor.

\hfill

Codigo: point2d.cpp

\begin{lstlisting}[language=C++]
template <typename T>
struct point {
    T x, y;
    point(T _x = 0, T _y = 0) : x(_x), y(_y) { }

    using p = point;

    p operator*(const T o) { return p(o * x, o * y); }
    p operator-(const p o) { return p(x - o.x, y - o.y); }
    p operator+(const p o) { return p(x + o.x, y + o.y); }
    T operator*(const p o) { return x * o.x + y * o.y; }
    T operator^(const p o) { return x * o.y - y * o.x; }
    bool operator<(const p o) const { return (x == o.x) ? y < o.y : x < o.x; }
    bool operator==(const p o) const { return (x == o.x) and (y == o.y); }
    bool operator!=(const p o) const { return (x != o.x) or (y != o.y); }

    T dist2(const p o) {
        T dx = x - o.x, dy = y - o.y;
        return dx * dx + dy * dy;
    }

    friend ostream &operator<<(ostream &out, const p &a) {
        return out << "(" << a.x << "," << a.y << ")";
    }
    friend istream &operator>>(istream &in, p &a) { return in >> a.x >> a.y; }
};

using pt = point<ll>;\end{lstlisting}
\hfill

\newpage

%%%%%%
%
%
% Geometria
%
%
%%%%%%

\chapter{Geometria}

\section{Convex Hull}


Algoritmo Graham's Scan para encontrar o fecho convexo de um conjunto de pontos em $\mathcal{O}(n \log n)$. Retorna os pontos do fecho convexo em sentido horário.



\textbf{Definição}: o fecho convexo de um conjunto de pontos é o menor polígono convexo que contém todos os pontos do conjunto.



\textbf{Obs}: utiliza a primitiva \texttt{Ponto 2D}. 

\hfill

Codigo: convex\_hull.cpp

\begin{lstlisting}[language=C++]
bool ccw(pt &p, pt &a, pt &b, bool include_collinear = 0) {
    pt p1 = a - p;
    pt p2 = b - p;
    return include_collinear ? (p2 ^ p1) <= 0 : (p2 ^ p1) < 0;
}

void sort_by_angle(vector<pt> &v) { // sorta o vetor por angulo em relacao ao pivo
    pt p0 = *min_element(begin(v), end(v));
    sort(begin(v), end(v), [&](pt &l, pt &r) { // sorta clockwise
        pt p1 = l - p0;
        pt p2 = r - p0;
        ll c1 = p1 ^ p2;
        return c1 < 0 || ((c1 == 0) && p0.dist2(l) < p0.dist2(r));
    });
}

vector<pt> convex_hull(vector<pt> v, bool include_collinear = 0) {
    int n = size(v);

    sort_by_angle(v);

    if (include_collinear) {
        for (int i = n - 2; i >= 0; i--) { // reverte o ultimo lado do poligono
            if (ccw(v[0], v[n - 1], v[i])) {
                reverse(begin(v) + i + 1, end(v));
                break;
            }
        }
    }

    vector<pt> ch{v[0], v[1]};
    for (int i = 2; i < n; i++) {
        while (ch.size() > 2 &&
               (ccw(ch.end()[-2], ch.end()[-1], v[i], !include_collinear)))
            ch.pop_back();
        ch.emplace_back(v[i]);
    }

    return ch;
}\end{lstlisting}
\hfill

\newpage

%%%%%%
%
%
% Matemática
%
%
%%%%%%

\chapter{Matemática}

\section{Eliminação Gaussiana}
\subsection{Gauss}


Método de eliminação gaussiana para resolução de sistemas lineares com coeficientes reais.



\begin{itemize}
\item Complexidade de tempo: $\mathcal{O}(n^3)$
\end{itemize}

\hfill

Codigo: gauss.cpp

\begin{lstlisting}[language=C++]
const double EPS = 1e-9;
const int INF = 2; // it doesn't actually have to
                   // be infinity or a big number

int gauss(vector<vector<double>> a, vector<double> &ans) {
    int n = (int)a.size();
    int m = (int)a[0].size() - 1;

    vector<int> where(m, -1);
    for (int col = 0, row = 0; col < m && row < n; ++col) {
        int sel = row;
        for (int i = row; i < n; ++i)
            if (abs(a[i][col]) > abs(a[sel][col])) sel = i;
        if (abs(a[sel][col]) < EPS) continue;
        for (int i = col; i <= m; ++i) swap(a[sel][i], a[row][i]);
        where[col] = row;

        for (int i = 0; i < n; ++i) {
            if (i != row) {
                double c = a[i][col] / a[row][col];
                for (int j = col; j <= m; ++j) a[i][j] -= a[row][j] * c;
            }
        }
        ++row;
    }

    ans.assign(m, 0);
    for (int i = 0; i < m; ++i)
        if (where[i] != -1) ans[i] = a[where[i]][m] / a[where[i]][i];
    for (int i = 0; i < n; ++i) {
        double sum = 0;
        for (int j = 0; j < m; ++j) sum += ans[j] * a[i][j];
        if (abs(sum - a[i][m]) > EPS) return 0;
    }

    for (int i = 0; i < m; ++i)
        if (where[i] == -1) return INF;
    return 1;
}
\end{lstlisting}
\hfill

\subsection{Gauss Mod 2}


Método de eliminação gaussiana para resolução de sistemas lineares com coeficientes em $\mathbb{Z}_2$ (inteiros módulo 2).



\begin{itemize}
\item Complexidade de tempo: $\mathcal{O}(n^3/32)$
\end{itemize}

\hfill

Codigo: gauss\_mod2.cpp

\begin{lstlisting}[language=C++]
const int N = 105;
const int INF = 2; // tanto faz

// n -> numero de equacoes, m -> numero de
// variaveis a[i][j] para j em [0, m - 1] ->
// coeficiente da variavel j na iesima equacao
// a[i][j] para j == m -> resultado da equacao da
// iesima linha ans -> bitset vazio, que retornara
// a solucao do sistema (caso exista)

int gauss(vector<bitset<N>> a, int n, int m, bitset<N> &ans) {
    vector<int> where(m, -1);

    for (int col = 0, row = 0; col < m && row < n; col++) {
        for (int i = row; i < n; i++) {
            if (a[i][col]) {
                swap(a[i], a[row]);
                break;
            }
        }
        if (!a[row][col]) continue;
        where[col] = row;

        for (int i = 0; i < n; i++)
            if (i != row && a[i][col]) a[i] ^= a[row];
        row++;
    }

    for (int i = 0; i < m; i++)
        if (where[i] != -1) ans[i] = a[where[i]][m] / a[where[i]][i];
    for (int i = 0; i < n; i++) {
        int sum = 0;
        for (int j = 0; j < m; j++) sum += ans[j] * a[i][j];
        if (abs(sum - a[i][m]) > 0) return 0; // Sem solucao
    }

    for (int i = 0; i < m; i++)
        if (where[i] == -1) return INF; // Infinitas solucoes
    // Unica solucao (retornada no bitset ans)
    return 1;
}
\end{lstlisting}
\hfill

\section{Exponenciação Modular Rápida}


Computa $(\text{base} ^ \text{exp}) \mod MOD$.



\begin{itemize}
\item Complexidade de tempo: $\mathcal{O}(\log(\text{exp}))$.
\item Complexidade de espaço: $\mathcal{O}(1)$
\end{itemize}

\hfill

Codigo: exp\_mod.cpp

\begin{lstlisting}[language=C++]
ll exp_mod(ll base, ll exp) {
    ll b = base, res = 1;
    while (exp) {
        if (exp & 1) res = (res * b) % MOD;
        b = (b * b) % MOD;
        exp /= 2;
    }
    return res;
}
\end{lstlisting}
\hfill

\section{FFT}


Algoritmo que computa a Transformada Rápida de Fourier para convolução de polinômios.



Computa convolução (multiplicação) de polinômios em $\mathcal{O}(N \cdot \log N)$, sendo $N$ a soma dos graus dos polinômios.



Testado e sem erros de precisão com polinômios de grau até $3 * 10^5$ e constantes até $10^6$. Para convolução de inteiros sem erro de precisão, consultar a seção de NTT.

\hfill

Codigo: fft.cpp

\begin{lstlisting}[language=C++]
struct base {
    double a, b;
    base(double _a = 0, double _b = 0) : a(_a), b(_b) { }
    const base operator+(const base &c) const { return base(a + c.a, b + c.b); }
    const base operator-(const base &c) const { return base(a - c.a, b - c.b); }
    const base operator*(const base &c) const {
        return base(a * c.a - b * c.b, a * c.b + b * c.a);
    }
};

using poly = vector<base>;
const double PI = acos(-1);

void fft(poly &a, bool inv = 0) {
    int n = (int)a.size();

    for (int i = 0; i < n; i++) {
        int bit = n >> 1, j = 0, k = i;
        while (bit > 0) {
            if (k & 1) j += bit;
            k >>= 1, bit >>= 1;
        }
        if (i < j) swap(a[i], a[j]);
    }

    double angle = 2 * PI / n * (inv ? -1 : 1);
    poly wn(n / 2);
    for (int i = 0; i < n / 2; i++) wn[i] = {cos(angle * i), sin(angle * i)};

    for (int len = 2; len <= n; len <<= 1) {
        int aux = len / 2;
        int step = n / len;
        for (int i = 0; i < n; i += len) {
            for (int j = 0; j < aux; j++) {
                base v = a[i + j + aux] * wn[step * j];
                a[i + j + aux] = a[i + j] - v;
                a[i + j] = a[i + j] + v;
            }
        }
    }

    for (int i = 0; inv && i < n; i++) a[i].a /= n, a[i].b /= n;
}

vector<ll> multiply(vector<ll> &ta, vector<ll> &tb) {
    int n = int(ta.size()), m = int(tb.size());
    int t = n + m - 1, sz = 1;
    while (sz < t) sz <<= 1;

    poly a(sz), b(sz), c(sz);

    for (int i = 0; i < sz; i++) {
        a[i] = i < n ? base((double)ta[i]) : base(0);
        b[i] = i < m ? base((double)tb[i]) : base(0);
    }

    fft(a, 0), fft(b, 0);
    for (int i = 0; i < sz; i++) c[i] = a[i] * b[i];
    fft(c, 1);

    vector<ll> res(sz);
    for (int i = 0; i < sz; i++) res[i] = ll(round(c[i].a));

    while ((int)res.size() > t && res.back() == 0) res.pop_back();

    return res;
}
\end{lstlisting}
\hfill

\section{Fatoração}


Algortimos para fatorar um número.



\textbf{Fatoração Simples} 

Fatora um número N.



\begin{itemize}
\item Complexidade de tempo: $\mathcal{O}(\sqrt n)$
\end{itemize}



\textbf{Crivo Linear} 

Pré-computa todos os fatores primos até MAX.

Utilizado para fatorar um número N menor que MAX.



\begin{itemize}
\item Complexidade de tempo: Pré-processamento $\mathcal{O}(\text{MAX})$
\item Complexidade de tempo: Fatoraração $\mathcal{O}(\text{quantidade de fatores de N})$
\item Complexidade de espaço: $\mathcal{O}(\text{MAX})$
\end{itemize}



\textbf{Fatoração Rápida} 

Utiliza Pollar-Rho e Miller-Rabin (ver em Primos) para fatorar um número N.



\begin{itemize}
\item Complexidade de tempo: $\mathcal{O}(N^{1/4} \cdot \log N))$
\end{itemize}



\textbf{Pollard-Rho} 

Descobre um divisor de um número N.



\begin{itemize}
\item Complexidade de tempo: $\mathcal{O}(\sqrt[4]{N} \cdot \log N)$
\item Complexidade de espaço: $\mathcal{O}(\sqrt N)$
\end{itemize}

\hfill

Codigo: naive\_factorize.cpp

\begin{lstlisting}[language=C++]
vector<int> factorize(int n) {
    vector<int> factors;
    for (long long d = 2; d * d <= n; d++) {
        while (n % d == 0) {
            factors.push_back(d);
            n /= d;
        }
    }
    if (n != 1) factors.push_back(n);
    return factors;
}
\end{lstlisting}
\hfill

Codigo: linear\_sieve\_factorize.cpp

\begin{lstlisting}[language=C++]
namespace sieve {
    const int MAX = 1e4;
    int lp[MAX + 1], factor[MAX + 1];
    vector<int> pr;
    void build() {
        for (int i = 2; i <= MAX; ++i) {
            if (lp[i] == 0) {
                lp[i] = i;
                pr.push_back(i);
            }
            for (int j = 0; i * pr[j] <= MAX; ++j) {
                lp[i * pr[j]] = pr[j];
                factor[i * pr[j]] = i;
                if (pr[j] == lp[i]) break;
            }
        }
    }
    vector<int> factorize(int x) {
        if (x < 2) return {};
        vector<int> v;
        for (int lpx = lp[x]; x >= lpx; x = factor[x]) v.emplace_back(lp[x]);
        return v;
    }
}
\end{lstlisting}
\hfill

Codigo: pollard\_rho.cpp

\begin{lstlisting}[language=C++]
long long mod_mul(long long a, long long b, long long m) { return (__int128)a * b % m; }

long long pollard_rho(long long n) {
    auto f = [n](long long x) { return mod_mul(x, x, n) + 1; };
    long long x = 0, y = 0, t = 30, prd = 2, i = 1, q;
    while (t++ % 40 || __gcd(prd, n) == 1) {
        if (x == y) x = ++i, y = f(x);
        if ((q = mod_mul(prd, max(x, y) - min(x, y), n))) prd = q;
        x = f(x), y = f(f(y));
    }
    return __gcd(prd, n);
}
\end{lstlisting}
\hfill

Codigo: fast\_factorize.cpp

\begin{lstlisting}[language=C++]
// usa miller_rabin.cpp!! olhar em
// matematica/primos usa pollar_rho.cpp!! olhar em
// matematica/fatoracao

vector<long long> factorize(long long n) {
    if (n == 1) return {};
    if (miller_rabin(n)) return {n};
    long long x = pollard_rho(n);
    auto l = factorize(x), r = factorize(n / x);
    l.insert(l.end(), all(r));
    return l;
}
\end{lstlisting}
\hfill

\section{GCD}


Algoritmo Euclides para computar o Máximo Divisor Comum (MDC em português; GCD em inglês), e variações.



*Read in [English](README.en.md)*



\textbf{Algoritmo de Euclides} 



Computa o Máximo Divisor Comum (MDC em português; GCD em inglês).



\begin{itemize}
\item Complexidade de tempo: $\mathcal{O}(\log n)$
\end{itemize}



Mais demorado que usar a função do compilador C++ \texttt{\_\_gcd(a,b)}.



\textbf{Algoritmo de Euclides Estendido} 



Algoritmo extendido de euclides que computa o Máximo Divisor Comum e os valores x e y tal que a * x + b * y = gcd(a, b).



\begin{itemize}
\item Complexidade de tempo: $\mathcal{O}(\log n)$
\end{itemize}

\hfill

Codigo: gcd.cpp

\begin{lstlisting}[language=C++]
long long gcd(long long a, long long b) { return (b == 0) ? a : gcd(b, a % b); }
\end{lstlisting}
\hfill

Codigo: extended\_gcd.cpp

\begin{lstlisting}[language=C++]
int extended_gcd(int a, int b, int &x, int &y) {
    x = 1, y = 0;
    int x1 = 0, y1 = 1;
    while (b) {
        int q = a / b;
        tie(x, x1) = make_tuple(x1, x - q * x1);
        tie(y, y1) = make_tuple(y1, y - q * y1);
        tie(a, b) = make_tuple(b, a - q * b);
    }
    return a;
}
\end{lstlisting}
\hfill

Codigo: extended\_gcd\_recursive.cpp

\begin{lstlisting}[language=C++]
ll extended_gcd(ll a, ll b, ll &x, ll &y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    } else {
        ll g = extended_gcd(b, a % b, y, x);
        y -= a / b * x;
        return g;
    }
}
\end{lstlisting}
\hfill

\section{Inverso Modular}


Algoritmos para calcular o inverso modular de um número. O inverso modular de um inteiro $a$ é outro inteiro $x$ tal que $a \cdot x \equiv 1 \pmod{MOD}$



O inverso modular de um inteiro $a$ é outro inteiro $x$ tal que $a * x$ é congruente a $1 \mod MOD$.



\textbf{Inverso Modular} 



Calcula o inverso modular de $a$.



Utiliza o algoritmo Exp Mod, portanto, espera-se que $MOD$ seja um número primo.



* Complexidade de tempo: $\mathcal{O}(\log(\text{MOD}))$.

* Complexidade de espaço: $\mathcal{O}(1)$.



\textbf{Inverso Modular por MDC Estendido} 



Calcula o inverso modular de $a$.



Utiliza o algoritmo Euclides Extendido, portanto, espera-se que $MOD$ seja coprimo com $a$.



Retorna $-1$ se essa suposição for quebrada.



* Complexidade de tempo: $\mathcal{O}(\log(\text{MOD}))$.

* Complexidade de espaço: $\mathcal{O}(1)$.



\textbf{Inverso Modular para 1 até MAX} 



Calcula o inverso modular para todos os números entre $1$ e $MAX$.



Espera-se que $MOD$ seja primo.



* Complexidade de tempo: $\mathcal{O}(\text{MAX})$.

* Complexidade de espaço: $\mathcal{O}(\text{MAX})$.



\textbf{Inverso Modular para todas as potências} 



Seja $b$ um número inteiro qualquer.



Calcula o inverso modular para todas as potências de $b$ entre $b^0$ e $b^MAX$.



É necessário calcular antecipadamente o inverso modular de $b$, para 2 é sempre $(MOD+1)/2$.



Espera-se que $MOD$ seja coprimo com $b$.



* Complexidade de tempo: $\mathcal{O}(\text{MAX})$.

* Complexidade de espaço: $\mathcal{O}(\text{MAX})$.
\hfill

Codigo: modular\_inverse\_linear.cpp

\begin{lstlisting}[language=C++]
ll inv[MAX];

void compute_inv(const ll m = MOD) {
    inv[1] = 1;
    for (int i = 2; i < MAX; i++) inv[i] = m - (m / i) * inv[m % i] % m;
}
\end{lstlisting}
\hfill

Codigo: modular\_inverse\_pow.cpp

\begin{lstlisting}[language=C++]
const ll INVB = (MOD + 1) / 2; // Modular inverse of the base,
                               // for 2 it is (MOD+1)/2

ll inv[MAX]; // Modular inverse of b^i

void compute_inv() {
    inv[0] = 1;
    for (int i = 1; i < MAX; i++) inv[i] = inv[i - 1] * INVB % MOD;
}
\end{lstlisting}
\hfill

Codigo: modular\_inverse.cpp

\begin{lstlisting}[language=C++]
ll inv(ll a) { return exp_mod(a, MOD - 2); }
\end{lstlisting}
\hfill

Codigo: modular\_inverse\_coprime.cpp

\begin{lstlisting}[language=C++]
int inv(int a) {
    int x, y;
    int g = extended_gcd(a, MOD, x, y);
    if (g == 1) return (x % m + m) % m;
    return -1;
}
\end{lstlisting}
\hfill

\section{NTT}
\subsection{NTT}


Computa a multiplicação de polinômios com coeficientes inteiros módulo um número primo em $\mathcal{O}(N \cdot \log N)$. Exatamente o mesmo algoritmo da FFT, mas com inteiros.



Esse código está com módulo $998.244.353$ $(119 \cdot 2^{23} + 1)$ e aceita polinômios de tamanho até $2^{23}$ = $8.388.608$ $\approx 8 \times 10^6$.



Para se alterar o módulo ou o tamanho máximo do polinômio, basta alterar as constantes \texttt{MOD}, \texttt{len\_ntt} e encontrar uma raiz da unidade de ordem \texttt{len\_ntt} módulo \texttt{MOD} (onde \texttt{len\_ntt} é uma potência de 2 e o tamanho máximo do polinômio), no código, essa raiz é a variável \texttt{root\_ntt}.



Formalmente, uma raiz da unidade de ordem $n$ módulo $p$ é um inteiro $g$ tal que $g^n \equiv 1 \pmod{p}$ e $g^k \not\equiv 1 \pmod{p}$ para todo $k$ tal que $0 < k < n$.



Algumas raízes conhecidas para alguns módulos e alguns tamanhos máximos de polinômios:



|           Módulo            |   Len    |       Raiz da Unidade       |

|-----------------------------|----------|-----------------------------|

|        $998.244.353$        | $2^{23}$ |          $102.292$          |

|       $1.004.535.809$       | $2^{21}$ |           $4.172$           |

|       $1.092.616.193$       | $2^{21}$ |            $155$            |

| $9.223.372.036.737.335.297$ | $2^{24}$ | $2.419.180.138.865.645.092$ |



Essa última raiz para esse módulo enorme está melhor descrita na seção NTT Big Mod.



\textbf{Obs}: Essa implementação usa a primitiva \texttt{Mint} desse Almanaque. Se você não quiser usar o \texttt{Mint}, basta substituir todas as ocorrências de \texttt{Mint} por \texttt{int} ou \texttt{long long} e tratar adequadamente as operações com aritmética modular.
\hfill

Codigo: ntt.cpp

\begin{lstlisting}[language=C++]
const int MOD = 998244353;
const int root_ntt = 102292;
const int len_ntt = 1 << 23;

using mint = Mint<MOD>;
using poly = vector<mint>;

void ntt(poly &a, bool inv = 0) {
    int n = (int)a.size();

    for (int i = 0; i < n; i++) {
        int bit = n >> 1, j = 0, k = i;
        while (bit > 0) {
            if (k & 1) j += bit;
            k >>= 1, bit >>= 1;
        }
        if (i < j) swap(a[i], a[j]);
    }

    poly wn(n / 2);
    mint root = root_ntt;   // change according to MOD
    int root_len = len_ntt; // change according to MOD

    while (root_len > n) {
        root = root * root;
        root_len >>= 1;
    }

    if (inv) root = mint(1) / root;

    for (int i = 0; i < n / 2; i++) wn[i] = (i == 0) ? 1 : wn[i - 1] * root;

    for (int len = 2; len <= n; len <<= 1) {
        int aux = len / 2;
        int step = n / len;
        for (int i = 0; i < n; i += len) {
            for (int j = 0; j < aux; j++) {
                mint v = a[i + j + aux] * wn[step * j];
                a[i + j + aux] = a[i + j] - v;
                a[i + j] = a[i + j] + v;
            }
        }
    }
    if (inv) {
        mint invn = mint(1) / n;
        for (int i = 0; i < n; i++) a[i] = a[i] * invn;
    }
}

vector<int> multiply(vector<int> &ta, vector<int> &tb) {
    int n = int(ta.size()), m = int(tb.size());
    int t = n + m - 1, sz = 1;
    while (sz < t) sz <<= 1;

    poly a(sz), b(sz), c(sz);

    for (int i = 0; i < sz; i++) {
        a[i].v = i < n ? ta[i] : 0;
        b[i].v = i < m ? tb[i] : 0;
    }

    ntt(a, 0), ntt(b, 0);
    for (int i = 0; i < sz; i++) c[i] = a[i] * b[i];
    ntt(c, 1);

    vector<int> res(sz);
    for (int i = 0; i < sz; i++) res[i] = c[i].v;

    while ((int)res.size() > t && res.back() == 0) res.pop_back();

    return res;
}\end{lstlisting}
\hfill

\subsection{NTT Big Mod}


Computa a multiplicação de polinômios com coeficientes inteiros módulo um número primo em $\mathcal{O}(N \cdot \log N)$. Esse código usa do mesmo código da NTT padrão, com alguns ajustes especificados nos comentários do código.



Esse código está com módulo $9.223.372.036.737.335.297$ $(549.755.813.881 \cdot 2^{24} + 1)$ e aceita polinômios de tamanho até $2^{24}$ = $16.777.216$ $\approx 1.7 \times 10^7$.



\textbf{Obs}: Essa implementação usa a primitiva \texttt{Mint} desse Almanaque. Se você não quiser usar o \texttt{Mint}, basta substituir todas as ocorrências de \texttt{Mint} por \texttt{int} ou \texttt{long long} e tratar adequadamente as operações com aritmética modular.
\hfill

Codigo: big\_ntt.cpp

\begin{lstlisting}[language=C++]
const ll BIG_MOD = 9223372036737335297LL; // 549755813881 * 2^24 + 1
ll root_ntt = 2419180138865645092LL;      // essa constante pode ser calculada
                                          // fazendo 3 ^ ((MOD - 1) / (1 << 24))
int len_ntt = 1 << 24;

using mint = Mint<BIG_MOD>;

using poly = vector<mint>;

void big_ntt(poly &a, bool inv = 0) {
    // exatamente o mesmo código da ntt
}

vector<ll> big_multiply(vector<ll> &ta, vector<ll> &tb) {
    // exatamente o mesmo código da multiply, porem usando vector<ll> ao inves de
    // vector<int> e chamando big_ntt ao inves de ntt
    // ...
    vector<ll> res(sz); // lembrando, usar vector<ll> ao inves de vector<int>
    // ...
    return res;
}\end{lstlisting}
\hfill

\section{Primos}


Algortimos relacionados a números primos.



\textbf{Crivo de Eratóstenes} 

Computa a primalidade de todos os números até N, quase tão rápido quanto o crivo linear.



\begin{itemize}
\item Complexidade de tempo: $\mathcal{O}(N \cdot \log(\log N))$
\end{itemize}



Demora 1 segundo para LIM igual a $3 * 10^7$.



\textbf{Miller-Rabin} 

Teste de primalidade garantido para números até $10^{24}$.



\begin{itemize}
\item Complexidade de tempo: $\mathcal{O}(\log N)$
\end{itemize}



\textbf{Teste Ingênuo} 

Computa a primalidade de um número N.



\begin{itemize}
\item Complexidade de tempo: $\mathcal{O}(\sqrt{N})$
\end{itemize}

\hfill

Codigo: sieve.cpp

\begin{lstlisting}[language=C++]
vector<bool> sieve(int n) {
    vector<bool> is_prime(n + 5, true);
    is_prime[0] = false;
    is_prime[1] = false;
    for (int i = 2; i * i <= n; i++) {
        if (is_prime[i])
            for (int j = i * i; j < n; j += i) is_prime[j] = false;
    }
    return is_prime;
}
\end{lstlisting}
\hfill

Codigo: naive\_is\_prime.cpp

\begin{lstlisting}[language=C++]
bool is_prime(int n) {
    for (int d = 2; d * d <= n; d++)
        if (n % d == 0) return false;
    return true;
}
\end{lstlisting}
\hfill

Codigo: miller\_rabin.cpp

\begin{lstlisting}[language=C++]
ll power(ll base, ll e, ll mod) {
    ll result = 1;
    base %= mod;
    while (e) {
        if (e & 1) result = (__int128)result * base % mod;
        base = (__int128)base * base % mod;
        e >>= 1;
    }
    return result;
}

bool is_composite(ll n, ll a, ll d, int s) {
    ll x = power(a, d, n);
    if (x == 1 || x == n - 1) return false;
    for (int r = 1; r < s; r++) {
        x = (__int128)x * x % n;
        if (x == n - 1) return false;
    }
    return true;
}

bool miller_rabin(ll n) {
    if (n < 2) return false;
    int r = 0;
    ll d = n - 1;
    while ((d & 1) == 0) d >>= 1, ++r;
    for (int a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41}) {
        if (n == a) return true;
        if (is_composite(n, a, d, r)) return false;
    }
    return true;
}
\end{lstlisting}
\hfill

\section{Sum of floor (n div i)}


Esse código computa, em $\mathcal{O}(\sqrt{n})$, o seguinte somatório:



$$ \sum_{i=1}^{n} \left\lfloor \frac{n}{i}\right\rfloor $$

\hfill

Codigo: sum\_of\_floor.cpp

\begin{lstlisting}[language=C++]
const int MOD = 1e9 + 7;

long long sumoffloor(long long n) {
    long long answer = 0, i;
    for (i = 1; i * i <= n; i++) {
        answer += n / i;
        answer %= MOD;
    }
    i--;
    for (int j = 1; n / (j + 1) >= i; j++) {
        answer += (((n / j - n / (j + 1)) % MOD) * j) % MOD;
        answer %= MOD;
    }
    return answer;
}
\end{lstlisting}
\hfill

\section{Teorema do Resto Chinês}


Algoritmo que resolve o sistema $x \equiv a_i \pmod{m_i}$, onde $m_i$ são primos entre si.



Retorna $-1$ se a resposta não existir.

\hfill

Codigo: crt.cpp

\begin{lstlisting}[language=C++]
ll extended_gcd(ll a, ll b, ll &x, ll &y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    } else {
        ll g = extended_gcd(b, a % b, y, x);
        y -= a / b * x;
        return g;
    }
}

ll crt(vector<ll> rem, vector<ll> mod) {
    int n = rem.size();
    if (n == 0) return 0;
    __int128 ans = rem[0], m = mod[0];
    for (int i = 1; i < n; i++) {
        ll x, y;
        ll g = extended_gcd(mod[i], m, x, y);
        if ((ans - rem[i]) % g != 0) return -1;
        ans = ans + (__int128)1 * (rem[i] - ans) * (m / g) * y;
        m = (__int128)(mod[i] / g) * (m / g) * g;
        ans = (ans % m + m) % m;
    }
    return ans;
}
\end{lstlisting}
\hfill

\section{Totiente de Euler}


Código para computar a  função Totiente de Euler, que conta quantos números inteiros positivos menores que $N$ são coprimos com $N$. A função é denotada por $\phi(N)$.



É possível computar o totiente de Euler para um único número em $\mathcal{O}(\sqrt{N})$ e para todos os números entre $1$ e $N$ em $\mathcal{O}(N \cdot \log (\log N))$.

\hfill

Codigo: phi\_1\_to\_n.cpp

\begin{lstlisting}[language=C++]
vector<int> phi_1_to_n(int n) {
    vector<int> phi(n + 1);
    for (int i = 0; i <= n; i++) phi[i] = i;
    for (int i = 2; i <= n; i++) {
        if (phi[i] == i)
            for (int j = i; j <= n; j += i) phi[j] -= phi[j] / i;
    }
    return phi;
}
\end{lstlisting}
\hfill

Codigo: phi.cpp

\begin{lstlisting}[language=C++]
int phi(int n) {
    int result = n;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            while (n % i == 0) n /= i;
            result -= result / i;
        }
    }
    if (n > 1) result -= result / n;
    return result;
}
\end{lstlisting}
\hfill

\end{document}
